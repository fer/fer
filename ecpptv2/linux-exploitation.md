---
description: >-
  Linux and other variants of UNIX make up a very large segment of the overall
  internet infrastructure (including Critical Infrastructure).
---

# ‚≠ê WIP - Linux Exploitation

{% hint style="danger" %}
**This document is still in progress...** 
{% endhint %}

## Information Gathering

Information gathering and enumeration phases of any penetration test are considered the most important.

It is the result of these phases of the engagement that lead us to identify vulnerabilities, misconfigurations and ultimately to exploitation.

### Remote Enumeration - Study Guide

Remote Enumeration is the process of gathering as much information as possible about a target system from across-the-network perspective using all of the tools we have at our disposal.

#### OS Fingerprinting Re-cap

As a typical first step in identifying the OS of a target, we can use `nmap`:

```bash
# --osscan-guess enables aggressive OS detection
nmap -O --osscan-guess <ip_address>

# Open ports that are ususally returned from a port scan can offer OS insights
nmap -v -sT -O <ip_address>
```

The remote enumeration phase often begins with port scans for both TCP and UDP ports against target system/s, including service version fingerprinting `-sV`  and can be accomplished with a `nmap` command:

```bash
nmap -v -sS -sU -sV -n 192.168.0.1/24
```

#### Enumerating NFS

One of these commonly found services is the Network File System protocol, which is a RPC-based file sharing protocol often found configured on Unix-like systems, is typically used to provide access to shared resources, and can be found listening on TCP and/or UDP port 2049. `nmap` can easily identify a system running NFS. Note that since NFS is an RPC-based service and relies on other RPC services \(as `mountd`\) it should be directly queried via the Portmapper service which is found on port TCP and/or UDP 111 when using `nmap` NSE scripts:

```bash
nmap -sT -sU -sV -p2049 <ip_address>
```

An administrator wishing to share files from an NFS server will configure what are known as "exports", which are the mechanism used by NFS in order to export directories, in other words, make entire directories available to other users over the network. Exports configured for any given NFS serve can usually be found in the `/etc/exports` file on a target host locally.

One common issue with NFS is that often administrators will configure exports with little attention to security and usually export directories in a manner that allows any host or IP address to connect, without any authentication and if you're luck, also provide write-access to directories. 

Once we've identified that a server is running NFS, the first thing we want to do is to query it with several `nmap` NS scripts \(`nfs-ls`, `nfs-showmount` and `nfs-stafts`\). We can find them with:

```bash
ls /usr/share/nmap/scripts/ | grep nfs

# now we can obtain results relevant to NFS:
nmap --script nfs-ls, nfs-showmount-nfs-statfs <ip_address>
```

Alternatively we can use the built-in `showmount` command with the `-e` or `--exports` switches to show any exports that would be available to us as well. However, we can see it won't return as much information as `nmap`:

```bash
showmount -e <ip_address>
```

Ideally, an administrator would want to explicitly define \(whitelist\) IP addresses or hosts that should be allowed to connect to the NFS server. Even in the case where our access is restricted due to an NFS whitelist configuration like the above, the output still gives us valuable information regarding which IP addresses or hosts can mount any available exports. In this scenario, that information would be useful in the case we can either spoof our IP address to match a whitelisted IP address or take control of a host which is allowed to connect.

Once we've gathered the relevant NFS server information and have confirmed a misconfiguration, we can attempt to mount the available exported directories. This can be accomplished by first creating a temporary directory as your mount point, and then the exported NFS directory can be mounted:

```bash
mkdir -p /mnt/home/bob
mount -t nfs <nfs_server_ip>:/home/bob /mnt/home/bob -o nolock
mount # just test 
cd /mnt/home/bob && ls -al
```

#### Enumerating Portmapper \(rpcbind\)

`Portmapper` \(or rpcbind\) is another common service found on a Linux-based systems and is used to essentially "map" RPC or "ONC RPC" \(Open Network Computing Remote Procedure Call\) services to their corresponding TCP or UDP ports on a target system.

Information gleaned from the portmap service can offer insight regarding ports that are listening on a machine, but that may not necessarily be accessible over the network. A target system may be running a custom RPC service that is only accessible from the local host or may be running NFS, but only accessible from the local network, etc. Knowing this information can give us more insight to local services that may be running which could help us in further exploiting a system if and when local access has been obtained. `Portmapper` is typically found listening on ports TCP/UDP 111 and in some cases ports TCP/UDP 32771 and can be enumerated using `nmap` NSE scripts, or by using the built-in `rpcinfo` command.

Querying a single port \(TCP/111\) essentially enumerates all related RPC-related service ports without us having to conduct a port scan against all those ports individually. Furthermore, ii gives us knowledge of which ports the system has open locally \(bound to localhost\), which we couldn't normally identify with a usual port scan.

`nmap`'s `rpcinfo` and `rpc-grind` NSE scripts can be used to enumerate the Portmapper and associated RPC services:

```bash
nmap --script rpc-grind,rpcinfo <ip_address> -p 111

# the stand-alone rpcinfo command can also give similar results
rpcinfo -p <ip_address>
```

#### SMB \(Samba\)

It's a Linux-based implementation of the SMB/CIFS protocols, provides a print and file sharing services for Windows clients within an environment. Recent versions can also seamlessly be integrated with Active Directory domains. Samba can offer us a great bit of information when enumerated properly. 

Depending on the configuration, we can obtain OS version, user accounts on the system, file shares, their permissions and potentially sensitive data, and, depending on its integration with Active Directory, can be used to enumerate much more information. Improperly configured Samba servers can also lead to remote code execution among other things.

| Service | Port |
| :--- | :--- |
| netbios-ns \(Name Service\) | 137/tcp, 137/udp |
| netbios-dgm \(Datagram Service\) | 138/tcp, 138/udp |
| netbios-ssn \(Session Service\) | 139/tcp, 139/udp |
| microsoft-ds \(Naked CIFS\) | 445/tcp |

Samba can be trivially identified with a version scan against the NetBIOS ports:

```bash
nmap -sT -sU -sV <ip_address> -p136,137,138,139,445 --open
```

There are several smb-related NSE scripts to get an idea of shares that available on the target. We can use:

```bash
nmap --script smb-enum-shares <ip_address>
```

Alternatively we can also use `smbclient` to obtain similar info about shares, including Workgroup and NetBIOS name. Simply hitting 'enter; at the authentication prompt to obtain results also confirms that anonymous or guest access to the Samba server is enabled:

```bash
smbclient -L <ip_address>
```

In addition to simply listing shares which we have access to, we also want to know what type of access we have to which shares \(read only, write, etc\) with `smbmap`:

```bash
smbmap -H <ip_address>
```

Once we've identified shares, we have several options for interacting with them:

```bash
smbclient \\\\<ip_address>\\<share_name>

# or

mkdir /mnt/folder
# apt install cifs-utils
mount -t cifs \\\\<ip_address>\\<share_name> /mnt/folder
cd /mnt/folder && ls -las
```

#### SMB Users

Enumerating users when it comes to Samba or over SMB can be accomplished in several ways. 

**Method \#1: bash "for loop" and rpcclient**

Using `rpcclient` and list of potential usernames we've gather from other phases of information gathering:

```bash
for u in $(cat users.txt)
do
    rpcclient -U "" <ip_address> -N --command="lookupnames $u"
done
grep "User: 1"
```

There are several options available with `rpcclient`. Some useful commands include `loopupsids`, `netshareenum`, `srvinfo` and `enumprivs`.

**Method \#2: Automated \(enum4linux\)**

It can be used to enumerate the following:

* Operating system
* Users
* Password Policies
* Group Membership
* Shares
* Domain/Workgroup Identification

```bash
enum4linux <ip_addess>
```

#### Enumerating SMTP Users

You're probably familiar with the `HELO`, `RCPT` or `MAIL` verbs if you've ever sent an email while directly connected to an email server via `telnet` or some other way.

The following information does apply for both Windows and Linux-based mail servers since SMTP is the underlying protocol, but since a large majority of mail servers in-use are Linux-based, we'll be focusing on enumerating users from `sendmail`. If the wild, you'll mostly encounter `sendmail`, `postfix`, `exim` or Microsoft Exchange.

Similar to the user enumeration process for SMB users, there are several ways to accomplish this task either using manual methods or using tools designed for the purpose of enumerating users form a mail server.

The first task is to enumerate which options, verbs or features are enabled on an SMTP server, usually found on TCP/25:

```bash
nmap --script smtp-commands <ip_address> -p 25

# or

nc <ip_address>

# or 

telnet <ip_address>
```

We are interested in: `RCPT`, `VRFY` and `EXPN`.

Using `RCPT TO`, we can enumerate users via direct connection to the mail server with either `telnet` or `nc`. 

```bash
telnet <ip_address>
HELO
MAIL FROM
```

Valid users will return a Status code of `250 2.1.5` while a `550 5.1.1` status code and `User unknown` message denotes a non-existent user.

Another feature we can use to enumerate users in the `EXPN` feature, which was designed to be used to query a mail server for a list of members within a mailing list on a server. 

The typical command would be `EXPN mailing-list-name` or `EXPN username`.

Valid users will return a Status Code of `250 2.1.5` while `550 5.1.1` status code and `User unknown` message denotes a non-existent user.

Lastly the `VRFY` request can also be used an is more common than the `EXPN` method. The same command line can be used with `VRFY` and the results are similar to the `EXPN` output. Same status codes are used.

`smtp-user-enum` is a great tool that automates the user enumeration process for SMTP. `smtp-user-enum` tests all three methods, `RCPT`, `EXPN` and `VRFY` against a list of users:

```bash
smtpuser-enum -M VRFY -U users.txt -t <ip_address>
smtpuser-enum -M EXPN -U admin1 -t <ip_address>
smtpuser-enum -M RCPT -D users.txt -T mail-server.ips.txt
smtpuser-enum -M EXPN -D example.com -U users.txt -t <ip_address>
```

{% embed url="https://github.com/CiscoCXSecurity/enum4linux" %}

{% embed url="https://en.wikipedia.org/wiki/Network\_File\_System" %}

{% embed url="https://en.wikipedia.org/wiki/Open\_Network\_Computing\_Remote\_Procedure\_Call" %}

{% embed url="https://en.wikipedia.org/wiki/Portmap" %}

{% embed url="https://en.wikipedia.org/wiki/Samba\_\(software\)" %}

{% embed url="https://www.proofpoint.com/us/products/email-protection/open-source-email-solution" %}

{% embed url="https://en.wikipedia.org/wiki/Server\_Message\_Block" %}

{% embed url="https://github.com/ShawnDEvans/smbmap" %}

{% embed url="http://pentestmonkey.net/tools/user-enumeration/smtp-user-enum" %}

{% embed url="https://github.com/insidetrust/statistically-likely-usernames" %}

{% embed url="https://cr.yp.to/smtp/mail.html" %}

{% embed url="https://cr.yp.to/smtp/vrfy.html" %}

### Local Enumeration - Study Guide







### ‚ñ∂ Information Gathering

### üß™Linux Exploitation: Lab 1 - Remote Enumeration

### üß™Linux Exploitation: Lab 2 - Local Enumeration

## Exploitation over the Network

### Remote Exploitation Introduction - Study Guide

### Password Spray Attack - Study Guide

### Exploiting Samba - Study Guide

### Exploiting Shellshock - Study Guide

### Exploiting Heartbleed - Study Guide

### Exploiting Java RMI Registry - Study Guide

### Exploiting Java Deserialization - Study Guide

### Exploiting Tomcat - Study Guide

### ‚ñ∂ Remote Exploitation

## Post Exploitation

### Post Exploitation Introduction - Study Guide

### Privilege Escalation - Study Guide

### Lateral Movement - Study Guide

### Data Exfiltration - Study Guide

### Maintaining Access - Study Guide

### ‚ñ∂ Post-Exploitation and Lateral Movement

### üß™ Linux Exploitation: Lab 3 - Remote Exploitation and Post Exploitation

### üß™ Linux Exploitation: Lab 4 - Lateral Movement

