# Pentesters Prerequisites

## Regular Expressions

Sometimes regular expressions are a concept difficult to understand and use. A regular expression is a set of characters that describes a search pattern. You can use this pattern in a very different way, for example you can search its presence in a string or in a text \(pattern-matching\).

Usually a pentester uses regular expressions to filter and extract information in documents, client-server communications, tools output and much more.

For instance, we could use them to extract all the email addresses of a web page as well as filter `nmap` results. From a "defensive" point of view, regular expressions are also commonly used to verify and sanitize inputs. This may be used to avoid the input having bad character or invalid text.

```ruby
>> "Hello World!!!" =~ /World/
=> 6
```

You can create a regexp object with:

* literal notation \(as shown\)
* %r notation
* OO notation

The `%r` notation works like `%` notation of strings. The `r` tells the interpreter to treat the string inside the delimiter as a regular expression. Similar to the string notation, delimiters are custom:

```ruby
/hello/
%r{hello}
%r!hello! # using ! delimiter
```

OO notation is simple. Just use `new` with `Regexp` class to create the corresponding Regexp object. You can also use `Regexp.compile` as a synonym for `Regexp.new`:

```ruby
%r[hello]
%r&hello&
Regexp.new("hello")
Regexp.compile("hello")
```

If you use a literal notation you can add a character modifier after the last `/` of the Regexp. The most commonly used modifier is the `i` character, which is used for case insensitive matching. If you use OO notation, you shoudl specify the correct attribute when you create the Regexp:

```ruby
"Hello World!!!" =~ /hello/i         # => 0
"Hello World!!!" =~ /world/i         # => 6

reg = Regexp.new("hello", Regexp::IGNORECASE) # => /hello/i
"Hello World!!!" =~ reg              # => 0
```

### Match Method

Regexp class provides some very useful methods. One of these is `match`. With a `MatchData` object you can get some information about the matching such as the position of the matched substring, the matched words and much more. You can treat `MatchData` as an array, where at each position you can find the matching substring.

```ruby
>> matching = /world/.match("Hello World!")     # => nil
>> matching = /world/i.match("Hello World!")    
>> matching[0]    # => "World"
>> matching[1]    # => nil
```

### Special characters

There are some characters with special meanings:

```ruby
() [] {} . ? + * | ^ $
```

## Dates and Time

## Files and Directories

