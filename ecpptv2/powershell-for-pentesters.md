---
description: >-
  PowerShell is a powerful built-in shell and scripting environment we can
  utilize as penetration testers considering its wide-spread availability on all
  modern Windows based systems.
---

# PowerShell for Pentesters

{% hint style="danger" %}
**This document is still in progress...** 
{% endhint %}

## Introduction

### Why PowerShell - Study Guide

Powershell is a powerful built-in shell and scripting environment we can utilize as penetration testers considering its wide-spread availability on all modern Windows-based systems.

The use of Powershell allows us to take advantage of the "living-off-the-land" concept, where using tools that are built-in to the OS work to our advantage once we've obtained access to a system.

There are many advantages to using Powershell as it relates to penetration testing with some of them being:

* Many organizations aren't actively hunting for Powershell activity since it is usually considered a "trusted" application.
* We can use Powershell to run, download or execute code, entirely within the memory process of the Powershell executable, helping us evade endpoint security solutions.
* We can use it to interface with the .NET and other Windows APIs.
* We can call Windows DLL unctions from within Powershell.
* We can use it to bypass application whitelisting implementations by running the usual OS commands from from the Powershell CLI.
* Many tools are already available to us for a large amount of purposes related to penetration testing.
* Having access to all of those things through Powershell helps us reduce our footprint and evade defense mechanisms while conducting post-exploitation tasks.
* Powershell is also easy to use, and there are many scripts and frameworks written that we can utilize for our offensive purposes.
* Furthermore, it doesn't take much to create our own scripts to carry out some of our tasks as we'll see in the modules that follow.

{% embed url="https://www.secureworks.com/blog/living-off-the-land" %}

{% embed url="https://github.com/PowerShellMafia/PowerSploit" %}

{% embed url="https://en.wikipedia.org/wiki/PowerShell" %}

### What is PowerShell - Study Guide

Powershell is a powerful built-in Command Line Interpreter or "shell", and task-oriented scripting language environment found on most current Windows Operating Systems starting with Windows 7 and through to Windows 2008 R2 and onward.

Powershell is typically used by administrators as it provides great functionality and flexibility in regards to managing Windows systems and automating tasks, which is mostly the reason why it's the perfect tool when it comes to our process as penetration testers.

Powershell is tightly integrated with the .NET framework, and it's built on top of it.

It also provides convenient access to the .NET Framework API, Component Object Model \(COM\) and Windows Management Instrumentation \(WMI\) which is another plus in regards to persistence methods and ways we can gather information.

Most of the time, we'll either be working with scripts commonly identified by the `.ps1` file extension, or through what are known as "Cmdlets" \(native Powershell commands\) of which we can also create our own, and other times, we'll be interacting directly with via the Powershell CLI.

{% embed url="https://docs.microsoft.com/en-us/powershell/scripting/developer/cmdlet/cmdlet-overview?view=powershell-7" %}

An important point to note as we navigate through the upcoming topics is that more recent versions of Powershell, specifically 5.0 and onward, introduce some potential hurdles in regards to detection, loggin and more restrictive modes.

{% embed url="https://en.wikipedia.org/wiki/PowerShell\#Versions" %}

{% embed url="https://devblogs.microsoft.com/powershell/powershell-constrained-language-mode/" %}

{% embed url="https://www.crowdstrike.com/blog/investigating-powershell-command-and-script-logging/" %}

In 2016, Powershell 6.0 \(Powershell Core\) was made available for several different platforms, including some major Linux distributions, MacOS and also as a Docker container image:

{% embed url="https://github.com/powershell/powershell" %}

{% embed url="https://docs.microsoft.com/en-us/powershell/scripting/developer/cmdlet/cmdlet-overview?view=powershell-7" %}

{% embed url="https://en.wikipedia.org/wiki/Command-line\_interface\#Command-line\_interpreter" %}

{% embed url="https://en.wikipedia.org/wiki/Component\_Object\_Model" %}

{% embed url="https://www.crowdstrike.com/blog/investigating-powershell-command-and-script-logging/" %}

{% embed url="https://devblogs.microsoft.com/powershell/powershell-core-6-0-generally-available-ga-and-supported/" %}

{% embed url="https://en.wikipedia.org/wiki/Windows\_Management\_Instrumentation" %}

## PowerShell Fundamentals

### The PowerShell CLI - Study Guide

The PowerShell CLI provides us with access to built-in cmdlets, modules, functions, features, and provides a way to create tasks, functions, variables interactively and more, directly from the CLI.

In most cases, accessing the CLI is as simple as just typing `powershell` in the Windows search filed from the Start menu. 

Alternatively, the shortcut to PowerShell can be found within `%appdata%\Microsoft\Windows\Start Menu\Programs\Windows PowerShell` directory.

Sometimes the shortcuts are unavailable; the PowerShell executable itself can be found in the `C:\Windows\System32\WindowsPowerShell\v1.0` directory.

If other versions are available on the system, they can be found in their corresponding version paths.

> **A note regarding 32-bit and 64-bit PowerShell executables**
>
> * If you're operating on a 64-bit system, the location of the 64-bit PowerShell executable can be found in `c:\Windows\System32\WindowsPowerShell`.
> * While the 32-bit version being located in the `C:\Windows\SysWOW64\WindowsPowerShell` directory.
> * This can be a bit confusing considering the directory naming convention.
> * Nonetheless, we can determine whether we're running in a 32-bit or 64-bit PowerShell environment from the CLI with the following command: `PS C:\> [Environment]::Is64BitProcess`.
> * Which should return `True` if the current PowerShell process is 64-bit.
> * On a 32-bit system, the executable will be in its usual location of: `c:\Windows\System32\WindowsPowerShell\*`.

When possible, we should try and launch PowerShell as the Administrator user as this will give us access to functions which we would be otherwise unable to access as Lower-Privileged user.

We can right-click on the Shortcut or Executable and select "Run As Administrator".

> Examples were tested on Windows 10.

```bash
powershell /?         # Alternatively: -Help or -?
```

#### Basic Usage

<table>
  <thead>
    <tr>
      <th style="text-align:left">Argument</th>
      <th style="text-align:left">Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align:left"><code>-ExecutionPolicy</code>
      </td>
      <td style="text-align:left">
        <p>PowerShell execution policy determines which scripts if any, we can run
          and can easily be disabled with the <code>Bypass</code> or <code>Unrestricted</code> arguments:</p>
        <p><code>powershell.exe -ExecutionPolicy Bypass .\scr.ps1</code>
        </p>
        <p><code>powershell.exe -ExecutionPolicy Unrestricted .\scr.ps1</code>
        </p>
        <p><code>powershell.exe -ep Bypass </code>
        </p>
        <p><code>powershell.exe -ex by</code>
        </p>
      </td>
    </tr>
    <tr>
      <td style="text-align:left"><code>-WindowStyle</code>
      </td>
      <td style="text-align:left">
        <p>Hides the Powershell window when used with the <code>Hidden</code> argument:</p>
        <p><code>powershell.exe -WindowStyle Hidden .\scr.ps1</code>
        </p>
        <p><code>powershell.exe -W h</code>
        </p>
        <p><code>powershell.exe -Wi hi</code>
        </p>
      </td>
    </tr>
    <tr>
      <td style="text-align:left"><code>-Command</code>
      </td>
      <td style="text-align:left">
        <p>Used to specify a Command or Script Block to run:</p>
        <p><code>powershell -Command Get-Process</code>
        </p>
        <p><code>powershell -command &quot;&amp; { Get-EventLog -LogName security }&quot;</code>
        </p>
      </td>
    </tr>
    <tr>
      <td style="text-align:left"><code>-EncondedCommand</code>
      </td>
      <td style="text-align:left">
        <p>Used to execute base64 encoded scripts or commands:</p>
        <p><code>powershell.exe -EncodedCommand $encodedCommand</code>
        </p>
        <p><code>powershell.exe -enco</code>
        </p>
        <p><code>powershell.exe -ec</code>
        </p>
      </td>
    </tr>
    <tr>
      <td style="text-align:left"><code>-NoProfile</code>
      </td>
      <td style="text-align:left">
        <p>Don&apos;t load any PowerShell profiles. Profiles are essentially scripts
          that run when the PowerShell executable is launched and can interfere with
          our operations:</p>
        <p><code>powershell.exe -NoProfile .\scr.ps1</code>
        </p>
      </td>
    </tr>
    <tr>
      <td style="text-align:left"><code>-Version</code>
      </td>
      <td style="text-align:left">
        <p>We can use it to downgrade the version of PowerShell. Requires that older
          versions are still installed on the target:</p>
        <p><code>powershell.exe -Version 2</code>
        </p>
      </td>
    </tr>
  </tbody>
</table>

#### Get-Help

Similar to Linux Man Pages. Obtain info related to any funciton, alias, module or cmdlet that PowerShell is aware of.

```bash
PS C:/> Get-Help Get-Help
PS C:/> Get-Help Get-Process -Full         # detailed info
PS C:/> Get-Help Get-Process -Examples     
PS C:/> Get-Help Get-Process -Online       

# Update help files from Microsoft
PS C:/> Update-Help
```

#### Get-Command

Allows us to list all cmdlets, aliases, functions workflows, filters scripts and any applications that are available for us to use in PowerShell.

Running `Get-Command` cmdlet without arguments will simply list all commands, but we can also use the -Name parameter to list any that are useful to us. For instance we can list all functions related to modification of the Windows Firewall with the following command:

```bash
PS C:/> Get-Command Name "Firewall"
```

{% embed url="https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about\_script\_blocks?view=powershell-7.1&viewFallbackFrom=powershell-6" %}

{% embed url="http://radar.oreilly.com/2013/06/powershell-command-line-introduction.html" %}

{% embed url="https://docs.microsoft.com/en-us/previous-versions/system-center/virtual-machine-manager-2008-r2/cc764318\(v=technet.10\)?redirectedfrom=MSDN" %}

### Cmdlets - Study Guide

"command-lets" are a big part of how we will leverage PowerShell for our offensive purposes.

* Light-weight PowerShell scripts that perform a single function \(can be as small as few lines of code\).
* Instances of [.NET Framework](https://docs.microsoft.com/en-us/previous-versions/gg145045%28v=vs.110%29?redirectedfrom=MSDN) classes derived from the [Cmdlet Base Class](https://docs.microsoft.com/en-us/dotnet/api/system.management.automation.cmdlet?redirectedfrom=MSDN&view=powershellsdk-7.0.0) and provide access to system functions.
* Cmdlets are native commands in PowerShell \(we can also create our own\).
* Typically written in a "Verb-Noun" file name format which helps us determine their function \(e.g.: `Invoke-Command`\).
* Typically used to return output to other Cmdlets to be the processed via a pipeline \(`|`\).
* Every cmdlet has it's own set of parameters which can be discovered through the `Get-Help` cmdlet as we've seen previously.

> **Important**
>
> It should be noted that most cmdlets, by default, when run without other parameters will return a limited set of information or "Columns"
>
> For example: just running `Get-ChildItem` cmdlet without any other arguments or options, returns four columns named `Mode`, `LastWriteTime`, `Length` and `Name`.
>
> But by piping the output of a cmdlet to the `Format-List` cmdlet, rather than columns an names we can return all named properties associates with its objects in a different list-like format:
>
> ```bash
> PS C:\> Get-ChildItem | Format-List *
> ```

#### Pipelining

An example of this processing of cmdlet output objects with pipelines would be something like the following, where a list of process is returned to be sorted with unique values, selecting the `ProcessName` objects:

```bash
PS C:\> Get-Process | Sort-Object -Unique | Select-Object ProcessName
```

We can also redirect the results of our pipeline operation to a file using a standard Redirect Operator \(`>`\):

```bash
PS C:\> Get-Process | Sort-Object -Unique | Select-Object ProcessName > uniq_procs.txt
```

#### Useful cmdlets: Get-Process

`Get-Process`will give a list of all processes. To get all of the information \(properties\) associated with all of the processes, we can pipe it to the `Format-List *` cmdlet and wildcard argument.

This will give us a better idea of how we can filter the data for specific properties.

```bash
PS C:\> Get-Process | Format-List *
```

We can further extend this to get information about specific processes and paths to their executables, by using the `Format-List` cmdlet and also specifying the `Path` property name:

```bash
PS C:\> Get-Process chrome, firefox | Sort-Object -Unique | Format-List Path
PS C:\> Get-Process chrome, firefox | Sort-Object -Unique | Format-List Path,Id
```

#### Useful cmdlets: Get-ChildItem

This one has an alias: `ls`.

To find what the aliases are for a specific cmdlet, we can use the `Get-Alias` cmdlet with the `-Definition` parameter followed by a cmdlet name:

```bash
PS C:\> Get-Alias -Definition Get-ChildItem # outputs dir, gci, ls
```

#### Useful cmdlets: Get-WmiObject

`select` is an alias for the `Select-Object` cmdlet.

We return all information about the Operating System:

```bash
PS C:\> Get-WmiObject -class win32_operatingsystem | select -Property *
PS C:\> Get-WmiObject -class win32_operatingsystem | fl *

# Obtain information regarding any WMI Class, for instance getting a detailed
# list of properties for all services with the "win32_service" class:

PS C:\> Get-WmiObject -class win32_service | Format-List *

# We can further extend our pipeline and filtering operation just 
# to give us `PathName` which includes command line args and paths to all 
# service executables:

PS C:\> Get-WmiObject -class win32_service | Sort-Object -Unique PathName | fl Pathname
```

#### Useful cmdlets: Export-Csv

Saving the information we're gathering to a file is important as well. We can either redirect the output of the pipeline operation to a file with the \(`>`\) Redirect Operator as we saw in an earlier example or sometimes, we may need the results in a different format for processing. 

For this we can pipe all of the output to the `Export-Csv` cmdlet and save the results in CSV format:

```bash
PS C:\> Get-WmiObject -class win32_operatingsystem | fl * | Export-Csv C:\host_info.csv
```

#### Exploring the Registry

For access to Windows Registry hives, PowerShell provides a convenient method with the following command, so we can easily navigate into areas we might be interested in with `cd` which is the alias for `Set-Location` and furthermore list contents of our current hive with `Get-ChildItem` cmdlet or `ls`:

```bash
PS C:\> cd HKLM: \
```

#### Useful cmdlets: Select-String

Along with the `-Path` and `-Pattern` args is yet another useful PowerShell command we can use to scour the system for files containing certain strings. 

```bash
PS C:\> Select-String -Path C:\users\user\Documents\*.txt -Pattern pass*
```

#### Useful cmdlets: Get-Content

Use this cmdlet to display the full contents of the `passwords.txt` file.

```bash
PS C:\> Get-Content CL\Users\user\Documents\passwords.txt
```

Alternatively we can obtain the same results by usign the `Get-ChildItem` cmdlet alias with the recursive parameter \(`ls -r`\) which lists files within a directory recursively, then, search for file types of `.txt` with the `-File` parameter.

We'll then pipe that to the `ForEach-Object` alias which is `%` and a script block `{}` that searches for the string `pass*` in all files in the path specified with the alias for the `Select-String` cmdlet \(`sls`\):

```bash
PS C:\> ls -r C:\Users\user\Documents -File *.txt | % {sls -Path $_ -Pattern pass* }
# $_ variable for current value in the pipeline
# % alias for ForEach-Object cmdlet
```

#### Useful cmdlets: Get-Service

Information regarding currently installed services and can be useful in the case we can identify a service which might be vulnerable to a privilege escalation exploit.

Running it without parameters or arguments simply returns a three column list of all services. 

We can extend those results, as we've seen before, with the `Sort-Object` cmdlet. In this example, all services starting with `s*` in descending order and sorting by the `Status` property:

```bash
PS C:\> Get-Service "s*" | Sort-Object Status -Descending
```

{% embed url="https://docs.microsoft.com/en-us/dotnet/api/system.management.automation.cmdlet?redirectedfrom=MSDN&view=powershellsdk-7.0.0" %}

{% embed url="https://docs.microsoft.com/en-us/powershell/scripting/developer/cmdlet/cmdlet-overview?view=powershell-7" %}

{% embed url="https://github.com/rebootuser/LinEnum" %}

{% embed url="https://docs.microsoft.com/en-us/previous-versions/gg145045\(v=vs.110\)?redirectedfrom=MSDN" %}

{% embed url="https://www.petri.com/understanding-the-powershell-pipeline?\_\_cf\_chl\_jschl\_tk\_\_=pmd\_tTxFDoklww1QbthpmvNS0UqYWfPcbeISGlO0nqXD1Aw-1630618646-0-gqNtZGzNAfujcnBszQhR" %}

{% embed url="https://docs.microsoft.com/en-us/previous-versions/technet-magazine/hh750381\(v=msdn.10\)?redirectedfrom=MSDN" %}

### Modules - Study Guide

A module is a set of PowerShell functionalities grouped together in the form of a single file that will typically have a `.psm1` file extension.

Modules are typically comprised of several components. However, not all components are necessary for the functionality module.

The components that can make up a typical module are:

* Any number of PowerShell scripts `.ps1` or other code files, such as a managed cmdlet assembly.
* Additional Assemblies, Help files, or scripts.
* A module [manifest ](https://docs.microsoft.com/en-us/powershell/scripting/developer/module/how-to-write-a-powershell-module-manifest?view=powershell-7)file.
* A directory which is used to contain all of the above.

There are also several different types of modules:

* [Script Modules](https://docs.microsoft.com/en-us/powershell/scripting/developer/module/how-to-write-a-powershell-script-module?view=powershell-7)
* [Binary Modules](https://docs.microsoft.com/en-us/powershell/scripting/developer/module/how-to-write-a-powershell-binary-module?view=powershell-7)
* [Manifest Modules](https://docs.microsoft.com/en-us/powershell/scripting/developer/module/how-to-write-a-powershell-module-manifest?view=powershell-7)
* [Dynamic Modules](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/new-module?view=powershell-7.1&viewFallbackFrom=powershell-6), created dynamically by scripts using the `New-Module` cmdlet

#### Get-Module

Modules are typically "imported" into the current PowerShell session. To obtain a list of all currently imported modules, we can use the `Get-Module` cmdlet:

```bash
PS C:\> Get-Module
PS C:\> Get-Module -ListAvailable
```

#### Import-Module

Modules wanted to be used need to be imported into the current PowerShell session first:

```bash
PS C:\> Import Module .\mod.psm1
```

Once we import a PowerShell module, all of its various cmdlets and other components become available to us, and we can simply then execute the cmdlets that are part of that module \(think of [PowerSploit](https://github.com/PowerShellMafia/PowerSploit)\).

#### PowerSploit

1. Download PowerSploit.
2. `PS C:\> $env:PSModulePath` : modules will need to be copied into this path. Cam be something like `C:\Users\user\Documents\WindowsPowerShell\Modules`.
3. Launch PowerShell Console and `Import-Module PowerSploit`. 
4. Run `Get-Module`.
5. Run `Get-Command -Module PowerSploit` to list all of the PowerSploit associated module with the `-Module` parameter.
6. Get help: `Get-Help Write-HihackDLL`.

{% hint style="warning" %}
**Antivirus alert**

Many exploitation frameworks will be detected as "hacking tools" and other signatures by a number of Antivirus solutions. This is somewhat "normal", it's Antivirus just doing its job, in this case, at detecting strings within the PowerShell scripts as being malicious, or flagging on names of modules. etc. Either way, you can create an exclude directory for your AV software for the purpose of this lesson and download the modules into a directory.
{% endhint %}

{% embed url="https://docs.microsoft.com/en-us/powershell/scripting/developer/module/how-to-write-a-powershell-binary-module?view=powershell-7" %}

{% embed url="https://docs.microsoft.com/en-us/powershell/scripting/developer/module/how-to-write-a-powershell-script-module?view=powershell-7" %}

{% embed url="https://docs.microsoft.com/en-us/powershell/scripting/developer/module/how-to-write-a-powershell-module-manifest?view=powershell-7" %}

{% embed url="https://github.com/rebootuser/LinEnum" %}

{% embed url="https://docs.microsoft.com/en-us/powershell/scripting/developer/module/writing-a-windows-powershell-module?view=powershell-7" %}

### Scripts - Study Guide

Scripts are another element of our leveraging of PowerShell as an offensive tool, and most of the time, this is probably the most common way we will utilize PowerShell for most tasks.

PowerShell Scripts are usually identified by the `.ps1` extension, the '1' indicating not the version of PowerShell, but rather the PowerShell engine. 

For the most part, we'll be dealing with the `.ps1` file.

PowerShell scripts can contain as little as a few commands to automate some tasks or be as comples as contain parameters, script arguments, loops, functions, and anything else related to capabilities that PowerShell offers as a scripting language.

Running a PowerShell console, using the \(dot-backslash\) `.\` notation for a script in our directory.

```bash
PS C:> .\example.ps1

# You may have to bypass the current execution policy (as shown earlier) 
# before you execute the script of your choosing!!
```

A very basic example of a PowerShell script which takes a file name as an argument would be something like:

{% code title="example.ps1" %}
```bash
Param(
    [parameter(mandatory=$true)][string]$file
)
Get-Content "$file"
```
{% endcode %}

The above script simply takes a file name as an argument for which it creates a variable called `$file` and runs the `Get-Content` cmdlet on our variable.

Now if we run this file while supplying the name of a file, in this case, `users.txt` which contains several usernames:

```bash
.\example1.ps1 users.txt
```

If we run the script without arguments, PowerShell will ask us for the file, since `mandatory=$true` has been set for the parameter function in our script.

Alternatively....



### Objects - Study Guide

## Offensive PowerShell

### Downloading and Execution - Study Guide

### Obfuscation - Study Guide

### Information Gathering and Recon - Study Guide

### Post-Exploitation with PowerShell - Study Guide

### PowerShell and Metasploit

### ▶ Empire Overview

### ▶ UAC Bypass PowerShell Exploit Script Walkthrough

### ▶ Introduction to Leveraging WMI and Methods for Persistence

### 🧪 Leveraging PowerShell During Exploitation

### 🧪 PowerShell for Post-exploitation and Lateral Movement



